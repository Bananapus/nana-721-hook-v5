{
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23",
	"id": "54d924ca0ce25025276cf9168aae3c9e",
	"input": {
		"language": "Solidity",
		"settings": {
			"viaIR": false,
			"optimizer": {
				"runs": 800,
				"enabled": true
			},
			"metadata": {
				"useLiteralContent": false,
				"bytecodeHash": "ipfs",
				"appendCBOR": true
			},
			"outputSelection": {
				"lib/forge-std/lib/ds-test/src/test.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Base.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Script.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdAssertions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdChains.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdCheats.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdError.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdInvariant.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdJson.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdMath.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdStorage.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdStyle.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/StdUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Test.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/Vm.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/console.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/console2.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/interfaces/IMulticall3.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/mocks/MockERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/mocks/MockERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"lib/forge-std/src/safeconsole.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/address-registry/script/helpers/AddressRegistryDeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/address-registry/src/JBAddressRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/address-registry/src/interfaces/IJBAddressRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/script/helpers/CoreDeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBController.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBDirectory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBFeelessAddresses.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBFundAccessLimits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBMultiTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBPermissions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBPrices.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBProjects.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBRulesets.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBSplits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBTerminalStore.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/JBTokens.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/abstract/JBControlled.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/abstract/JBPermissioned.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/enums/JBApprovalStatus.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBCashOutHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBCashOutTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBControlled.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBController.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBDirectory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBDirectoryAccessControl.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFeeTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFeelessAddresses.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFundAccessLimits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBMigratable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBMultiTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPayHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPayoutTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermitTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPriceFeed.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPrices.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBProjectUriRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesetDataHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesets.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBSplitHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBSplits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTerminalStore.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBToken.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTokens.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBCashOuts.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBConstants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBCurrencyIds.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBFees.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBFixedPointNumber.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBMetadataResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBRulesetMetadataResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBSplitGroupIds.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/libraries/JBSurplus.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBAccountingContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBAfterCashOutRecordedContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBAfterPayRecordedContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBBeforeCashOutRecordedContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBBeforePayRecordedContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBCashOutHookSpecification.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBCurrencyAmount.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBFee.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBFundAccessLimitGroup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBPayHookSpecification.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRuleset.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetWeightCache.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetWithMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBSingleAllowance.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBSplit.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBSplitGroup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBSplitHookContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBTerminalConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/src/structs/JBTokenAmount.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/core/test/helpers/MetadataResolverHelper.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/JBOwnable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/JBOwnableOverrides.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/interfaces/IJBOwnable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/ownable/src/struct/JBOwner.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/access/Ownable.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/governance/utils/IVotes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/governance/utils/Votes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC1363.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC165.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC2981.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC5267.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC5805.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC6372.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/proxy/Clones.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/utils/ERC721Utils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/Address.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/Context.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/Errors.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/Nonces.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/Panic.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/ShortStrings.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/StorageSlot.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/Strings.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/structs/Checkpoints.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@openzeppelin/contracts/utils/types/Time.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/Common.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/SphinxDataTypes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/interfaces/ISphinxModule.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/interfaces/ISphinxModuleProxyFactory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/StdUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/Vm.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC165.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IMulticall3.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/mocks/MockERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/mocks/MockERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/Sphinx.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxConstants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxForkCheck.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxPlugin.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxPluginTypes.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxUtils.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/ICreateCall.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IEnum.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafe.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafeProxy.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafeProxyFactory.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IMultiSend.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/permit2/src/interfaces/IEIP712.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/permit2/src/interfaces/IPermit2.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/permit2/src/interfaces/ISignatureTransfer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/solady/src/utils/LibClone.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"script/Deploy.s.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"script/helpers/Hook721DeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JB721TiersHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JB721TiersHookDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JB721TiersHookProjectDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JB721TiersHookStore.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/abstract/ERC721.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/abstract/JB721Hook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IJB721Hook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IJB721TiersHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IJB721TiersHookDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IJB721TiersHookProjectDeployer.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IJB721TiersHookStore.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IJB721TokenUriResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/libraries/JB721Constants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/libraries/JB721TiersRulesetMetadataResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/libraries/JBBitmap.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/libraries/JBIpfsDecoder.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JB721InitTiersConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JB721Tier.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JB721TierConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JB721TiersHookFlags.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JB721TiersMintReservesConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JB721TiersRulesetMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JB721TiersSetDiscountPercentConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBBitmapWord.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBDeploy721TiersHookConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBLaunchProjectConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBLaunchRulesetsConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBPayDataHookRulesetConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBPayDataHookRulesetMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBQueueRulesetsConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBStored721Tier.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/E2E/Pay_Mint_Redeem_E2E.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/unit/adjustTier_Unit.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/unit/deployer_Unit.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/unit/getters_constructor_Unit.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/unit/mintFor_mintReservesFor_Unit.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/unit/pay_Unit.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/unit/redeem_Unit.t.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/utils/AccessJBLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/utils/ForTest_JB721TiersHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/utils/TestBaseWorkflow.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/utils/UnitTestSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				}
			},
			"evmVersion": "paris",
			"libraries": {},
			"remappings": [
				"@sphinx-labs/contracts/=node_modules/@sphinx-labs/contracts/contracts/foundry/",
				"@bananapus/=node_modules/@bananapus/",
				"@chainlink/=node_modules/@chainlink/",
				"@eth-optimism/=node_modules/@eth-optimism/",
				"@openzeppelin/=node_modules/@openzeppelin/",
				"@prb/=node_modules/@prb/",
				"@scroll-tech/=node_modules/@scroll-tech/",
				"@uniswap/=node_modules/@uniswap/",
				"ds-test/=lib/forge-std/lib/ds-test/src/",
				"forge-std/=lib/forge-std/src/",
				"hardhat/=node_modules/hardhat/",
				"solady/=node_modules/solady/",
				"solmate/=node_modules/solmate/",
				"sphinx/=lib/sphinx/packages/contracts/contracts/forge-std/src/"
			]
		},
		"sources": {
			"node_modules/@prb/math/src/Common.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// Common.sol\n//\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\n\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\nerror PRBMath_MulDivSigned_InputTooSmall();\n\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev The maximum value a uint128 number can have.\nuint128 constant MAX_UINT128 = type(uint128).max;\n\n/// @dev The maximum value a uint40 number can have.\nuint40 constant MAX_UINT40 = type(uint40).max;\n\n/// @dev The maximum value a uint64 number can have.\nuint64 constant MAX_UINT64 = type(uint64).max;\n\n/// @dev The unit number, which the decimal precision of the fixed-point types.\nuint256 constant UNIT = 1e18;\n\n/// @dev The unit number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\n/// bit in the binary representation of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // The following logic multiplies the result by $\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\n        //\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\n        // we know that `x & 0xFF` is also 1.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // In the code snippet below, two operations are executed simultaneously:\n        //\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\n        //\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\n        // integer part, $2^n$.\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\n///\n/// @dev See the note on \"msb\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each step in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\n///\n/// The Yul instructions used below are:\n///\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly (\"memory-safe\") {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly (\"memory-safe\") {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly (\"memory-safe\") {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly (\"memory-safe\") {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly (\"memory-safe\") {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly (\"memory-safe\") {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly (\"memory-safe\") {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly (\"memory-safe\") {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates x*ydenominator with 512-bit precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - The denominator must not be zero.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as a uint256.\n/// @param y The multiplier as a uint256.\n/// @param denominator The divisor as a uint256.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 512 by 256 division\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512-bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    unchecked {\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        uint256 flippedLpotdod;\n\n        assembly (\"memory-safe\") {\n            // Factor powers of two out of denominator.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * flippedLpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates x*y1e18 with 512-bit precision.\n///\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\n///\n/// Notes:\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\n/// - The result is rounded toward zero.\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\n///\n/// $$\n/// \\begin{cases}\n///     x * y = MAX\\_UINT256 * UNIT \\\\\n///     (x * y) \\% UNIT \\geq \\frac{UNIT}{2}\n/// \\end{cases}\n/// $$\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath_MulDiv18_Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        remainder := mulmod(x, y, UNIT)\n        result :=\n            mul(\n                or(\n                    div(sub(prod0, remainder), UNIT_LPOTD),\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n                ),\n                UNIT_INVERSE\n            )\n    }\n}\n\n/// @notice Calculates x*ydenominator with 512-bit precision.\n///\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit in int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath_MulDivSigned_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 xAbs;\n    uint256 yAbs;\n    uint256 dAbs;\n    unchecked {\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of x*ydenominator. The result must fit in int256.\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\n    if (resultAbs > uint256(type(int256).max)) {\n        revert PRBMath_MulDivSigned_Overflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly (\"memory-safe\") {\n        // \"sgt\" is the \"signed greater than\" assembly instruction and \"sub(0,1)\" is -1 in two's complement.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n"
			},
			"src/JB721TiersHookStore.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {IJB721TiersHookStore} from \"./interfaces/IJB721TiersHookStore.sol\";\nimport {IJB721TokenUriResolver} from \"./interfaces/IJB721TokenUriResolver.sol\";\nimport {JB721Constants} from \"./libraries/JB721Constants.sol\";\nimport {JBBitmap} from \"./libraries/JBBitmap.sol\";\nimport {JB721Tier} from \"./structs/JB721Tier.sol\";\nimport {JB721TierConfig} from \"./structs/JB721TierConfig.sol\";\nimport {JB721TiersHookFlags} from \"./structs/JB721TiersHookFlags.sol\";\nimport {JBBitmapWord} from \"./structs/JBBitmapWord.sol\";\nimport {JBStored721Tier} from \"./structs/JBStored721Tier.sol\";\n\n/// @title JB721TiersHookStore\n/// @notice This contract stores and manages data for many `IJB721TiersHook`s and their NFTs.\ncontract JB721TiersHookStore is IJB721TiersHookStore {\n    using JBBitmap for mapping(uint256 => uint256);\n    using JBBitmap for JBBitmapWord;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error JB721TiersHookStore_CantMintManually();\n    error JB721TiersHookStore_CantRemoveTier();\n    error JB721TiersHookStore_DiscountPercentExceedsBounds(uint256 percent, uint256 limit);\n    error JB721TiersHookStore_DiscountPercentIncreaseNotAllowed(uint256 percent, uint256 storedPercent);\n    error JB721TiersHookStore_PriceExceedsAmount(uint256 price, uint256 leftoverAmount);\n    error JB721TiersHookStore_InsufficientPendingReserves(uint256 count, uint256 numberOfPendingReserves);\n    error JB721TiersHookStore_InvalidCategorySortOrder(uint256 tierCategory, uint256 previousTierCategory);\n    error JB721TiersHookStore_InvalidQuantity(uint256 quantity, uint256 limit);\n    error JB721TiersHookStore_MaxTiersExceeded(uint256 numberOfTiers, uint256 limit);\n    error JB721TiersHookStore_InsufficientSupplyRemaining();\n    error JB721TiersHookStore_ReserveFrequencyNotAllowed();\n    error JB721TiersHookStore_ManualMintingNotAllowed();\n    error JB721TiersHookStore_TierRemoved(uint256 tierId);\n    error JB721TiersHookStore_UnrecognizedTier();\n    error JB721TiersHookStore_VotingUnitsNotAllowed();\n    error JB721TiersHookStore_ZeroInitialSupply();\n\n    //*********************************************************************//\n    // -------------------- private constant properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice Just a kind reminder to our readers.\n    /// @dev Used in 721 token ID generation.\n    uint256 private constant _ONE_BILLION = 1_000_000_000;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns the default reserve beneficiary for the provided 721 contract.\n    /// @dev If a tier has a reserve beneficiary set, it will override this value.\n    /// @custom:param hook The 721 contract to get the default reserve beneficiary of.\n    mapping(address hook => address) public override defaultReserveBeneficiaryOf;\n\n    /// @notice Returns the encoded IPFS URI for the provided tier ID of the provided 721 contract.\n    /// @dev Token URIs managed by this contract are stored in 32 bytes, based on stripped down IPFS hashes.\n    /// @custom:param hook The 721 contract that the tier belongs to.\n    /// @custom:param tierId The ID of the tier to get the encoded IPFS URI of.\n    /// @custom:returns The encoded IPFS URI.\n    mapping(address hook => mapping(uint256 tierId => bytes32)) public override encodedIPFSUriOf;\n\n    /// @notice Returns the largest tier ID currently used on the provided 721 contract.\n    /// @dev This may not include the last tier ID if it has been removed.\n    /// @custom:param hook The 721 contract to get the largest tier ID from.\n    mapping(address hook => uint256) public override maxTierIdOf;\n\n    /// @notice Returns the number of NFTs which have been burned from the provided tier ID of the provided 721\n    /// contract.\n    /// @custom:param hook The 721 contract that the tier belongs to.\n    /// @custom:param tierId The ID of the tier to get the burn count of.\n    mapping(address hook => mapping(uint256 tierId => uint256)) public override numberOfBurnedFor;\n\n    /// @notice Returns the number of reserve NFTs which have been minted from the provided tier ID of the provided 721\n    /// contract.\n    /// @custom:param hook The 721 contract that the tier belongs to.\n    /// @custom:param tierId The ID of the tier to get the reserve mint count of.\n    mapping(address hook => mapping(uint256 tierId => uint256)) public override numberOfReservesMintedFor;\n\n    /// @notice Returns the number of NFTs which the provided owner address owns from the provided 721 contract and tier\n    /// ID.\n    /// @custom:param hook The 721 contract to get the balance from.\n    /// @custom:param owner The address to get the tier balance of.\n    /// @custom:param tierId The ID of the tier to get the balance for.\n    mapping(address hook => mapping(address owner => mapping(uint256 tierId => uint256))) public override tierBalanceOf;\n\n    /// @notice Returns the custom token URI resolver which overrides the default token URI resolver for the provided\n    /// 721 contract.\n    /// @custom:param hook The 721 contract to get the custom token URI resolver of.\n    mapping(address hook => IJB721TokenUriResolver) public override tokenUriResolverOf;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice Returns the flags which dictate the behavior of the provided `IJB721TiersHook` contract.\n    /// @custom:param hook The address of the 721 contract to get the flags for.\n    /// @custom:returns The flags.\n    mapping(address hook => JB721TiersHookFlags) internal _flagsOf;\n\n    /// @notice Return the ID of the last sorted tier from the provided 721 contract.\n    /// @dev If not set, it is assumed the `maxTierIdOf` is the last sorted tier ID.\n    /// @custom:param hook The 721 contract to get the last sorted tier ID from.\n    mapping(address hook => uint256) internal _lastTrackedSortedTierIdOf;\n\n    /// @notice Get the bitmap word at the provided depth from the provided 721 contract's tier removal bitmap.\n    /// @dev See `JBBitmap` for more information.\n    /// @custom:param hook The 721 contract to get the bitmap word from.\n    /// @custom:param depth The depth of the bitmap row to get. Each row stores 256 tiers.\n    /// @custom:returns word The bitmap row's content.\n    mapping(address hook => mapping(uint256 depth => uint256 word)) internal _removedTiersBitmapWordOf;\n\n    /// @notice Returns the reserve beneficiary (if there is one) for the provided tier ID on the provided\n    /// `IJB721TiersHook` contract.\n    /// @custom:param hook The address of the 721 contract to get the reserve beneficiary from.\n    /// @custom:param tierId The ID of the tier to get the reserve beneficiary of.\n    /// @custom:returns The address of the reserved token beneficiary.\n    mapping(address hook => mapping(uint256 tierId => address)) internal _reserveBeneficiaryOf;\n\n    /// @notice Returns the ID of the first tier in the provided category on the provided 721 contract.\n    /// @custom:param hook The 721 contract to get the category's first tier ID from.\n    /// @custom:param category The category to get the first tier ID of.\n    mapping(address hook => mapping(uint256 category => uint256)) internal _startingTierIdOfCategory;\n\n    /// @notice Returns the stored tier of the provided tier ID on the provided `IJB721TiersHook` contract.\n    /// @custom:param hook The address of the 721 contract to get the tier from.\n    /// @custom:param tierId The ID of the tier to get.\n    /// @custom:returns The stored tier, as a `JBStored721Tier` struct.\n    mapping(address hook => mapping(uint256 tierId => JBStored721Tier)) internal _storedTierOf;\n\n    /// @notice Returns the ID of the tier which comes after the provided tier ID (sorted by price).\n    /// @dev If empty, assume the next tier ID should come after.\n    /// @custom:param hook The address of the 721 contract to get the next tier ID from.\n    /// @custom:param tierId The ID of the tier to get the next tier ID in relation to.\n    /// @custom:returns The following tier's ID.\n    mapping(address hook => mapping(uint256 tierId => uint256)) internal _tierIdAfter;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Resolves the encoded IPFS URI for the tier of the 721 with the provided token ID from the provided 721\n    /// contract.\n    /// @param hook The 721 contract that the encoded IPFS URI belongs to.\n    /// @param tokenId The token ID of the 721 to get the encoded tier IPFS URI of.\n    /// @return The encoded IPFS URI.\n    function encodedTierIPFSUriOf(address hook, uint256 tokenId) external view override returns (bytes32) {\n        return encodedIPFSUriOf[hook][tierIdOfToken(tokenId)];\n    }\n\n    /// @notice Get the flags that dictate the behavior of the provided 721 contract.\n    /// @param hook The 721 contract to get the flags of.\n    /// @return The flags.\n    function flagsOf(address hook) external view override returns (JB721TiersHookFlags memory) {\n        return _flagsOf[hook];\n    }\n\n    /// @notice Check if the provided tier has been removed from the provided 721 contract.\n    /// @param hook The 721 contract the tier belongs to.\n    /// @param tierId The ID of the tier to check the removal status of.\n    /// @return A bool which is `true` if the tier has been removed, and `false` otherwise.\n    function isTierRemoved(address hook, uint256 tierId) external view override returns (bool) {\n        JBBitmapWord memory bitmapWord = _removedTiersBitmapWordOf[hook].readId(tierId);\n\n        return bitmapWord.isTierIdRemoved(tierId);\n    }\n\n    /// @notice Get the number of pending reserve NFTs for the provided tier ID of the provided 721 contract.\n    /// @dev \"Pending\" means that the NFTs have been reserved, but have not been minted yet.\n    /// @param hook The 721 contract to check for pending reserved NFTs.\n    /// @param tierId The ID of the tier to get the number of pending reserves for.\n    /// @return The number of pending reserved NFTs.\n    function numberOfPendingReservesFor(address hook, uint256 tierId) external view override returns (uint256) {\n        return _numberOfPendingReservesFor(hook, tierId, _storedTierOf[hook][tierId]);\n    }\n\n    /// @notice Get the tier with the provided ID from the provided 721 contract.\n    /// @param hook The 721 contract to get the tier from.\n    /// @param id The ID of the tier to get.\n    /// @param includeResolvedUri If set to `true`, if the contract has a token URI resolver, its content will be\n    /// resolved and included.\n    /// @return The tier.\n    function tierOf(\n        address hook,\n        uint256 id,\n        bool includeResolvedUri\n    )\n        public\n        view\n        override\n        returns (JB721Tier memory)\n    {\n        return _getTierFrom(hook, id, _storedTierOf[hook][id], includeResolvedUri);\n    }\n\n    /// @notice Get the tier of the 721 with the provided token ID in the provided 721 contract.\n    /// @param hook The 721 contract that the tier belongs to.\n    /// @param tokenId The token ID of the 721 to get the tier of.\n    /// @param includeResolvedUri If set to `true`, if the contract has a token URI resolver, its content will be\n    /// resolved and included.\n    /// @return The tier.\n    function tierOfTokenId(\n        address hook,\n        uint256 tokenId,\n        bool includeResolvedUri\n    )\n        external\n        view\n        override\n        returns (JB721Tier memory)\n    {\n        // Get a reference to the tier's ID.\n        uint256 tierId = tierIdOfToken(tokenId);\n        return _getTierFrom(hook, tierId, _storedTierOf[hook][tierId], includeResolvedUri);\n    }\n\n    /// @notice Returns the number of voting units an addresses has within the specified tier of the specified 721\n    /// contract.\n    /// @dev NFTs have a tier-specific number of voting units. If the tier does not have a custom number of voting\n    /// units, the price is used.\n    /// @param hook The 721 contract that the tier belongs to.\n    /// @param account The address to get the voting units of within the tier.\n    /// @param tierId The ID of the tier to get voting units within.\n    /// @return The address' voting units within the tier.\n    function tierVotingUnitsOf(\n        address hook,\n        address account,\n        uint256 tierId\n    )\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        // Get a reference to the account's balance in this tier.\n        uint256 balance = tierBalanceOf[hook][account][tierId];\n\n        if (balance == 0) return 0;\n\n        // Keep a reference to the stored tier.\n        JBStored721Tier memory storedTier = _storedTierOf[hook][tierId];\n\n        // Check if voting units should be used. Price will be used otherwise.\n        (,, bool useVotingUnits,,) = _unpackBools(storedTier.packedBools);\n\n        // Return the address' voting units within the tier.\n        return balance * (useVotingUnits ? storedTier.votingUnits : storedTier.price);\n    }\n\n    /// @notice Gets an array of currently active 721 tiers for the provided 721 contract.\n    /// @param hook The 721 contract to get the tiers of.\n    /// @param categories An array tier categories to get tiers from. Send an empty array to get all categories.\n    /// @param includeResolvedUri If set to `true`, if the contract has a token URI resolver, its content will be\n    /// resolved and included.\n    /// @param startingId The ID of the first tier to get (sorted by price). Send 0 to get all active tiers.\n    /// @param size The number of tiers to include.\n    /// @return tiers An array of active 721 tiers.\n    function tiersOf(\n        address hook,\n        uint256[] calldata categories,\n        bool includeResolvedUri,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        override\n        returns (JB721Tier[] memory tiers)\n    {\n        // Keep a reference to the last tier ID.\n        uint256 lastTierId = _lastSortedTierIdOf(hook);\n\n        // Return an empty array if there are no tiers.\n        if (lastTierId == 0) return tiers;\n\n        // Initialize an array with the provided length.\n        tiers = new JB721Tier[](size);\n\n        // Count the number of tiers to include in the result.\n        uint256 numberOfIncludedTiers;\n\n        // Keep a reference to the tier being iterated upon.\n        JBStored721Tier memory storedTier;\n\n        // Initialize a `JBBitmapWord` to track if whether tiers have been removed.\n        JBBitmapWord memory bitmapWord;\n\n        // Keep a reference to an iterator variable to represent the category being iterated upon.\n        uint256 i;\n\n        // Iterate at least once.\n        do {\n            // Stop iterating if the size limit has been reached.\n            if (numberOfIncludedTiers == size) break;\n\n            // Get a reference to the ID of the tier being iterated upon, starting with the first tier ID if no starting\n            // ID was specified.\n            uint256 currentSortedTierId =\n                startingId != 0 ? startingId : _firstSortedTierIdOf(hook, categories.length == 0 ? 0 : categories[i]);\n\n            // Add the tiers from the category being iterated upon.\n            while (currentSortedTierId != 0 && numberOfIncludedTiers < size) {\n                if (!_isTierRemovedWithRefresh(hook, currentSortedTierId, bitmapWord)) {\n                    storedTier = _storedTierOf[hook][currentSortedTierId];\n\n                    // If categories were provided and the current tier's category is greater than category being added,\n                    // break.\n                    if (categories.length != 0 && storedTier.category > categories[i]) {\n                        break;\n                    }\n                    // If a category is specified and matches, add the returned values.\n                    else if (categories.length == 0 || storedTier.category == categories[i]) {\n                        // Add the tier to the array being returned.\n                        tiers[numberOfIncludedTiers++] =\n                            _getTierFrom(hook, currentSortedTierId, storedTier, includeResolvedUri);\n                    }\n                }\n                // Set the next sorted tier ID.\n                currentSortedTierId = _nextSortedTierIdOf(hook, currentSortedTierId, lastTierId);\n            }\n\n            unchecked {\n                i++;\n            }\n        } while (i < categories.length);\n\n        // Resize the array if there are removed tiers.\n        if (numberOfIncludedTiers != size) {\n            assembly (\"memory-safe\") {\n                mstore(tiers, numberOfIncludedTiers)\n            }\n        }\n    }\n\n    /// @notice Get the number of NFTs which have been minted from the provided 721 contract (across all tiers).\n    /// @param hook The 721 contract to get a total supply of.\n    /// @return supply The total number of NFTs minted from all tiers on the contract.\n    function totalSupplyOf(address hook) external view override returns (uint256 supply) {\n        // Keep a reference to the greatest tier ID.\n        uint256 maxTierId = maxTierIdOf[hook];\n\n        for (uint256 i = maxTierId; i != 0; i--) {\n            // Set the tier being iterated on.\n            JBStored721Tier memory storedTier = _storedTierOf[hook][i];\n\n            // Increment the total supply by the number of tokens already minted.\n            supply += storedTier.initialSupply - storedTier.remainingSupply;\n        }\n    }\n\n    /// @notice Get the number of voting units the provided address has for the provided 721 contract (across all\n    /// tiers).\n    /// @dev NFTs have a tier-specific number of voting units. If the tier does not have a custom number of voting\n    /// units, the price is used.\n    /// @param hook The 721 contract to get the voting units within.\n    /// @param account The address to get the voting unit total of.\n    /// @return units The total voting units the address has within the 721 contract.\n    function votingUnitsOf(address hook, address account) external view virtual override returns (uint256 units) {\n        // Keep a reference to the greatest tier ID.\n        uint256 maxTierId = maxTierIdOf[hook];\n\n        // Loop through all tiers.\n        for (uint256 i = maxTierId; i != 0; i--) {\n            // Get a reference to the account's balance in this tier.\n            uint256 balance = tierBalanceOf[hook][account][i];\n\n            // If the account has no balance, return.\n            if (balance == 0) continue;\n\n            // Get the tier.\n            JBStored721Tier memory storedTier = _storedTierOf[hook][i];\n\n            // Parse the flags.\n            (,, bool useVotingUnits,,) = _unpackBools(storedTier.packedBools);\n\n            // Add the voting units for the address' balance in this tier.\n            // Use custom voting units if set. Otherwise, use the tier's price.\n            units += balance * (useVotingUnits ? storedTier.votingUnits : storedTier.price);\n        }\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Get the number of NFTs that the specified address has from the specified 721 contract (across all\n    /// tiers).\n    /// @param hook The 721 contract to get the balance within.\n    /// @param owner The address to check the balance of.\n    /// @return balance The number of NFTs the owner has from the 721 contract.\n    function balanceOf(address hook, address owner) public view override returns (uint256 balance) {\n        // Keep a reference to the greatest tier ID.\n        uint256 maxTierId = maxTierIdOf[hook];\n\n        // Loop through all tiers.\n        for (uint256 i = maxTierId; i != 0; i--) {\n            // Get a reference to the account's balance within this tier.\n            balance += tierBalanceOf[hook][owner][i];\n        }\n    }\n\n    /// @notice The combined cash out weight of the NFTs with the provided token IDs.\n    /// @dev Cash out weight is based on 721 price.\n    /// @dev Divide this result by the `totalCashOutWeight` to get the portion of funds that can be reclaimed by\n    /// cashing out these NFTs.\n    /// @param hook The 721 contract that the NFTs belong to.\n    /// @param tokenIds The token IDs of the NFTs to get the cash out weight of.\n    /// @return weight The cash out weight.\n    function cashOutWeightOf(address hook, uint256[] calldata tokenIds) public view override returns (uint256 weight) {\n        // Add each 721's price (from its tier) to the weight.\n        for (uint256 i; i < tokenIds.length; i++) {\n            weight += _storedTierOf[hook][tierIdOfToken(tokenIds[i])].price;\n        }\n    }\n\n    /// @notice The reserve beneficiary for the provided tier ID on the provided 721 contract.\n    /// @param hook The 721 contract that the tier belongs to.\n    /// @param tierId The ID of the tier to get the reserve beneficiary of.\n    /// @return The reserve beneficiary for the tier.\n    function reserveBeneficiaryOf(address hook, uint256 tierId) public view override returns (address) {\n        // Get the stored reserve beneficiary.\n        address storedReserveBeneficiaryOfTier = _reserveBeneficiaryOf[hook][tierId];\n\n        // If the tier has a beneficiary specified, return it.\n        if (storedReserveBeneficiaryOfTier != address(0)) {\n            return storedReserveBeneficiaryOfTier;\n        }\n\n        // Otherwise, return the contract's default reserve benficiary.\n        return defaultReserveBeneficiaryOf[hook];\n    }\n\n    /// @notice The tier ID for the 721 with the provided token ID.\n    /// @dev Tiers are 1-indexed from the `tiers` array, meaning the 0th element of the array is tier 1.\n    /// @param tokenId The token ID of the 721 to get the tier ID of.\n    /// @return The ID of the 721's tier.\n    function tierIdOfToken(uint256 tokenId) public pure override returns (uint256) {\n        return tokenId / _ONE_BILLION;\n    }\n\n    /// @notice The combined cash out weight for all NFTs from the provided 721 contract.\n    /// @param hook The 721 contract to get the total cash out weight of.\n    /// @return weight The total cash out weight.\n    function totalCashOutWeight(address hook) public view override returns (uint256 weight) {\n        // Keep a reference to the greatest tier ID.\n        uint256 maxTierId = maxTierIdOf[hook];\n\n        // Add each 721's price (from its tier) to the weight.\n        for (uint256 i = 1; i <= maxTierId; i++) {\n            // Keep a reference to the stored tier.\n            JBStored721Tier memory storedTier = _storedTierOf[hook][i];\n\n            // Add the tier's price multiplied by the number of NFTs minted from the tier.\n            weight += storedTier.price\n                * (\n                    (storedTier.initialSupply - storedTier.remainingSupply)\n                        + _numberOfPendingReservesFor(hook, i, storedTier)\n                );\n        }\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Cleans an 721 contract's removed tiers from the tier sorting sequence.\n    /// @param hook The 721 contract to clean tiers for.\n    function cleanTiers(address hook) external override {\n        // Keep a reference to the last tier ID.\n        uint256 lastSortedTierId = _lastSortedTierIdOf(hook);\n\n        // Get a reference to the tier ID being iterated on, starting with the starting tier ID.\n        uint256 currentSortedTierId = _firstSortedTierIdOf(hook, 0);\n\n        // Keep track of the previous non-removed tier ID.\n        uint256 previousSortedTierId;\n\n        // Initialize a `JBBitmapWord` for tracking removed tiers.\n        JBBitmapWord memory bitmapWord;\n\n        // Make the sorted array.\n        while (currentSortedTierId != 0) {\n            // If the current tier ID being iterated on isn't an increment of the previous one,\n            if (!_isTierRemovedWithRefresh(hook, currentSortedTierId, bitmapWord)) {\n                // Update its `_tierIdAfter` if needed.\n                if (currentSortedTierId != previousSortedTierId + 1) {\n                    if (_tierIdAfter[hook][previousSortedTierId] != currentSortedTierId) {\n                        _tierIdAfter[hook][previousSortedTierId] = currentSortedTierId;\n                    }\n                    // Otherwise, if the current tier ID IS an increment of the previous one,\n                    // AND the tier ID after it isn't 0,\n                } else if (_tierIdAfter[hook][previousSortedTierId] != 0) {\n                    // Set its `_tierIdAfter` to 0.\n                    _tierIdAfter[hook][previousSortedTierId] = 0;\n                }\n\n                // Iterate by setting the previous tier ID for the next loop to the current tier ID.\n                previousSortedTierId = currentSortedTierId;\n            }\n            // Iterate by updating the current sorted tier ID to the next sorted tier ID.\n            currentSortedTierId = _nextSortedTierIdOf(hook, currentSortedTierId, lastSortedTierId);\n        }\n\n        emit CleanTiers({hook: hook, caller: msg.sender});\n    }\n\n    /// @notice Record newly added tiers.\n    /// @param tiersToAdd The tiers to add.\n    /// @return tierIds The IDs of the tiers being added.\n    function recordAddTiers(JB721TierConfig[] calldata tiersToAdd)\n        external\n        override\n        returns (uint256[] memory tierIds)\n    {\n        // Keep a reference to the current greatest tier ID.\n        uint256 currentMaxTierIdOf = maxTierIdOf[msg.sender];\n\n        // Make sure the max number of tiers won't be exceeded.\n        if (currentMaxTierIdOf + tiersToAdd.length > type(uint16).max) {\n            revert JB721TiersHookStore_MaxTiersExceeded(currentMaxTierIdOf + tiersToAdd.length, type(uint16).max);\n        }\n\n        // Keep a reference to the current last sorted tier ID (sorted by price).\n        uint256 currentLastSortedTierId = _lastSortedTierIdOf(msg.sender);\n\n        // Initialize an array for the new tier IDs to be returned.\n        tierIds = new uint256[](tiersToAdd.length);\n\n        // Keep a reference to the first sorted tier ID, to use when sorting new tiers if needed.\n        // There's no need for sorting if there are no current tiers.\n        uint256 startSortedTierId = currentMaxTierIdOf == 0 ? 0 : _firstSortedTierIdOf(msg.sender, 0);\n\n        // Keep track of the previous tier's ID while iterating.\n        uint256 previousTierId;\n\n        // Keep a reference to the 721 contract's flags.\n        JB721TiersHookFlags memory flags = _flagsOf[msg.sender];\n\n        for (uint256 i; i < tiersToAdd.length; i++) {\n            // Set the tier being iterated upon.\n            JB721TierConfig memory tierToAdd = tiersToAdd[i];\n\n            // Make sure the supply maximum is enforced. If it's greater than one billion, it would overflow into the\n            // next tier.\n            if (tierToAdd.initialSupply > _ONE_BILLION - 1) {\n                revert JB721TiersHookStore_InvalidQuantity(tierToAdd.initialSupply, _ONE_BILLION - 1);\n            }\n\n            // Keep a reference to the previous tier.\n            JB721TierConfig memory previousTier;\n\n            // Make sure the tier's category is greater than or equal to the previously added tier's category.\n            if (i != 0) {\n                // Set the reference to the previously added tier.\n                previousTier = tiersToAdd[i - 1];\n\n                // Revert if the category is not equal or greater than the previously added tier's category.\n                if (tierToAdd.category < previousTier.category) {\n                    revert JB721TiersHookStore_InvalidCategorySortOrder(tierToAdd.category, previousTier.category);\n                }\n            }\n\n            // Make sure the new tier doesn't have voting units if the 721 contract's flags don't allow it to.\n            if (\n                flags.noNewTiersWithVotes\n                    && (\n                        (tierToAdd.useVotingUnits && tierToAdd.votingUnits != 0)\n                            || (!tierToAdd.useVotingUnits && tierToAdd.price != 0)\n                    )\n            ) {\n                revert JB721TiersHookStore_VotingUnitsNotAllowed();\n            }\n\n            // Make sure the new tier doesn't have a reserve frequency if the 721 contract's flags don't allow it to,\n            // OR if manual minting is allowed.\n            if ((flags.noNewTiersWithReserves || tierToAdd.allowOwnerMint) && tierToAdd.reserveFrequency != 0) {\n                revert JB721TiersHookStore_ReserveFrequencyNotAllowed();\n            }\n\n            // Make sure the new tier doesn't have owner minting enabled if the 721 contract's flags don't allow it to.\n            if (flags.noNewTiersWithOwnerMinting && tierToAdd.allowOwnerMint) {\n                revert JB721TiersHookStore_ManualMintingNotAllowed();\n            }\n\n            // Make sure the discount percent is within the bound.\n            if (tierToAdd.discountPercent > JB721Constants.MAX_DISCOUNT_PERCENT) {\n                revert JB721TiersHookStore_DiscountPercentExceedsBounds(\n                    tierToAdd.discountPercent, JB721Constants.MAX_DISCOUNT_PERCENT\n                );\n            }\n\n            // Make sure the tier has a non-zero supply.\n            if (tierToAdd.initialSupply == 0) revert JB721TiersHookStore_ZeroInitialSupply();\n\n            // Get a reference to the ID for the new tier.\n            uint256 tierId = currentMaxTierIdOf + i + 1;\n\n            // Store the tier with that ID.\n            _storedTierOf[msg.sender][tierId] = JBStored721Tier({\n                price: uint104(tierToAdd.price),\n                remainingSupply: uint32(tierToAdd.initialSupply),\n                initialSupply: uint32(tierToAdd.initialSupply),\n                votingUnits: uint32(tierToAdd.votingUnits),\n                reserveFrequency: uint16(tierToAdd.reserveFrequency),\n                category: uint24(tierToAdd.category),\n                discountPercent: uint8(tierToAdd.discountPercent),\n                packedBools: _packBools(\n                    tierToAdd.allowOwnerMint,\n                    tierToAdd.transfersPausable,\n                    tierToAdd.useVotingUnits,\n                    tierToAdd.cannotBeRemoved,\n                    tierToAdd.cannotIncreaseDiscountPercent\n                )\n            });\n\n            // If this is the first tier in a new category, store it as the first tier in that category.\n            // The `_startingTierIdOfCategory` of the category \"0\" will always be the same as the `_tierIdAfter` the 0th\n            // tier.\n            if (previousTier.category != tierToAdd.category && tierToAdd.category != 0) {\n                _startingTierIdOfCategory[msg.sender][tierToAdd.category] = tierId;\n            }\n\n            // Set the reserve beneficiary if needed.\n            if (tierToAdd.reserveBeneficiary != address(0) && tierToAdd.reserveFrequency != 0) {\n                if (tierToAdd.useReserveBeneficiaryAsDefault) {\n                    if (defaultReserveBeneficiaryOf[msg.sender] != tierToAdd.reserveBeneficiary) {\n                        defaultReserveBeneficiaryOf[msg.sender] = tierToAdd.reserveBeneficiary;\n                    }\n                } else {\n                    _reserveBeneficiaryOf[msg.sender][tierId] = tierToAdd.reserveBeneficiary;\n                }\n            }\n\n            // Set the `encodedIPFSUri` if needed.\n            if (tierToAdd.encodedIPFSUri != bytes32(0)) {\n                encodedIPFSUriOf[msg.sender][tierId] = tierToAdd.encodedIPFSUri;\n            }\n\n            if (startSortedTierId != 0) {\n                // Keep track of the sorted tier ID being iterated on.\n                uint256 currentSortedTierId = startSortedTierId;\n\n                // Keep a reference to the tier ID to iterate to next.\n                uint256 nextTierId;\n\n                // Make sure the tier is sorted correctly.\n                while (currentSortedTierId != 0) {\n                    // Set the next tier ID.\n                    nextTierId = _nextSortedTierIdOf(msg.sender, currentSortedTierId, currentLastSortedTierId);\n\n                    // If the category is less than or equal to the sorted tier being iterated on,\n                    // AND the tier being iterated on isn't among those being added, store the order.\n                    if (\n                        tierToAdd.category <= _storedTierOf[msg.sender][currentSortedTierId].category\n                            && currentSortedTierId <= currentMaxTierIdOf\n                    ) {\n                        // If the tier ID being iterated on isn't the next tier ID, set the `_tierIdAfter` (next tier\n                        // ID).\n                        if (currentSortedTierId != tierId + 1) {\n                            _tierIdAfter[msg.sender][tierId] = currentSortedTierId;\n                        }\n\n                        // If this is the first tier being added, track it as the current last sorted tier ID (if it's\n                        // not already tracked).\n                        if (_lastTrackedSortedTierIdOf[msg.sender] != currentLastSortedTierId) {\n                            _lastTrackedSortedTierIdOf[msg.sender] = currentLastSortedTierId;\n                        }\n\n                        // If the previous tier's `_tierIdAfter` was set to something else, update it.\n                        if (previousTierId != tierId - 1 || _tierIdAfter[msg.sender][previousTierId] != 0) {\n                            // Set the the previous tier's `_tierIdAfter` to the tier being added, or 0 if the tier ID\n                            // is\n                            // incremented.\n                            _tierIdAfter[msg.sender][previousTierId] = previousTierId == tierId - 1 ? 0 : tierId;\n                        }\n\n                        // When the next tier is being added, start at the sorted tier just set.\n                        startSortedTierId = currentSortedTierId;\n\n                        // Use the current tier ID as the \"previous tier ID\" when the next tier is being added.\n                        previousTierId = tierId;\n\n                        // Set the current sorted tier ID to zero to break out of the loop (the tier has been sorted).\n                        currentSortedTierId = 0;\n                    }\n                    // If the tier being iterated on is the last tier, add the new tier after it.\n                    else if (nextTierId == 0 || nextTierId > currentMaxTierIdOf) {\n                        if (tierId != currentSortedTierId + 1) {\n                            _tierIdAfter[msg.sender][currentSortedTierId] = tierId;\n                        }\n\n                        // For the next tier being added, start at this current tier ID.\n                        startSortedTierId = tierId;\n\n                        // Break out.\n                        currentSortedTierId = 0;\n\n                        // If there's currently a last sorted tier ID tracked, override it.\n                        if (_lastTrackedSortedTierIdOf[msg.sender] != 0) _lastTrackedSortedTierIdOf[msg.sender] = 0;\n                    }\n                    // Move on to the next tier ID.\n                    else {\n                        // Set the previous tier ID to be the current tier ID.\n                        previousTierId = currentSortedTierId;\n\n                        // Go to the next tier ID.\n                        currentSortedTierId = nextTierId;\n                    }\n                }\n            }\n\n            // Add the tier ID to the array being returned.\n            tierIds[i] = tierId;\n        }\n\n        // Update the maximum tier ID to include the new tiers.\n        maxTierIdOf[msg.sender] = currentMaxTierIdOf + tiersToAdd.length;\n    }\n\n    /// @notice Records 721 burns.\n    /// @param tokenIds The token IDs of the NFTs to burn.\n    function recordBurn(uint256[] calldata tokenIds) external override {\n        // Iterate through all token IDs to increment the burn count.\n        for (uint256 i; i < tokenIds.length; i++) {\n            // Set the 721's token ID.\n            uint256 tokenId = tokenIds[i];\n\n            uint256 tierId = tierIdOfToken(tokenId);\n\n            // Increment the number of NFTs burned from the tier.\n            numberOfBurnedFor[msg.sender][tierId]++;\n\n            // Increment the remaining supply of the tier.\n            _storedTierOf[msg.sender][tierId].remainingSupply++;\n        }\n    }\n\n    /// @notice Record newly set flags.\n    /// @param flags The flags to set.\n    function recordFlags(JB721TiersHookFlags calldata flags) external override {\n        _flagsOf[msg.sender] = flags;\n    }\n\n    /// @notice Record 721 mints from the provided tiers.\n    /// @param amount The amount being spent on NFTs. The total price must not exceed this amount.\n    /// @param tierIds The IDs of the tiers to mint from.\n    /// @param isOwnerMint A flag indicating whether this function is being directly called by the 721 contract's owner.\n    /// @return tokenIds The token IDs of the NFTs which were minted.\n    /// @return leftoverAmount The `amount` remaining after minting.\n    function recordMint(\n        uint256 amount,\n        uint16[] calldata tierIds,\n        bool isOwnerMint\n    )\n        external\n        override\n        returns (uint256[] memory tokenIds, uint256 leftoverAmount)\n    {\n        // Set the leftover amount as the initial amount.\n        leftoverAmount = amount;\n\n        // Keep a reference to the tier being iterated on.\n        JBStored721Tier storage storedTier;\n\n        // Get a reference to the number of tiers.\n        uint256 numberOfTiers = tierIds.length;\n\n        // Initialize the array for the token IDs to be returned.\n        tokenIds = new uint256[](numberOfTiers);\n\n        // Initialize a `JBBitmapWord` for checking whether tiers have been removed.\n        JBBitmapWord memory bitmapWord;\n\n        for (uint256 i; i < numberOfTiers; i++) {\n            // Set the tier ID being iterated on.\n            uint256 tierId = tierIds[i];\n\n            // Make sure the tier hasn't been removed.\n            if (_isTierRemovedWithRefresh(msg.sender, tierId, bitmapWord)) {\n                revert JB721TiersHookStore_TierRemoved(tierId);\n            }\n\n            // Keep a reference to the stored tier being iterated on.\n            storedTier = _storedTierOf[msg.sender][tierId];\n\n            // Parse the flags.\n            (bool allowOwnerMint,,,,) = _unpackBools(storedTier.packedBools);\n\n            // If this is an owner mint, make sure owner minting is allowed.\n            if (isOwnerMint && !allowOwnerMint) revert JB721TiersHookStore_CantMintManually();\n\n            // Make sure the provided tier exists (tiers cannot have a supply of 0).\n            if (storedTier.initialSupply == 0) revert JB721TiersHookStore_UnrecognizedTier();\n\n            // Get a reference to the price.\n            uint256 price = storedTier.price;\n\n            // Apply a discount if needed.\n            if (storedTier.discountPercent > 0) {\n                price -= mulDiv(price, storedTier.discountPercent, JB721Constants.MAX_DISCOUNT_PERCENT);\n            }\n\n            // Make sure the `amount` is greater than or equal to the tier's price.\n            if (price > leftoverAmount) revert JB721TiersHookStore_PriceExceedsAmount(price, leftoverAmount);\n\n            // Make sure there are enough NFTs available to mint.\n            if (storedTier.remainingSupply <= _numberOfPendingReservesFor(msg.sender, tierId, storedTier)) {\n                revert JB721TiersHookStore_InsufficientSupplyRemaining();\n            }\n\n            // Mint the 721.\n            unchecked {\n                // Keep a reference to its token ID.\n                tokenIds[i] = _generateTokenId(\n                    tierId,\n                    storedTier.initialSupply - --storedTier.remainingSupply + numberOfBurnedFor[msg.sender][tierId]\n                );\n                leftoverAmount = leftoverAmount - price;\n            }\n        }\n    }\n\n    /// @notice Record reserve 721 minting for the provided tier ID on the provided 721 contract.\n    /// @param tierId The ID of the tier to mint reserves from.\n    /// @param count The number of reserve NFTs to mint.\n    /// @return tokenIds The token IDs of the reserve NFTs which were minted.\n    function recordMintReservesFor(\n        uint256 tierId,\n        uint256 count\n    )\n        external\n        override\n        returns (uint256[] memory tokenIds)\n    {\n        // Get a reference to the stored tier.\n        JBStored721Tier storage storedTier = _storedTierOf[msg.sender][tierId];\n\n        // Get a reference to the number of pending reserve NFTs for the tier.\n        // \"Pending\" means that the NFTs have been reserved, but have not been minted yet.\n        uint256 numberOfPendingReserves = _numberOfPendingReservesFor(msg.sender, tierId, storedTier);\n\n        // Can't mint more than the number of pending reserves.\n        if (count > numberOfPendingReserves) {\n            revert JB721TiersHookStore_InsufficientPendingReserves(count, numberOfPendingReserves);\n        }\n\n        // Increment the number of reserve NFTs minted.\n        numberOfReservesMintedFor[msg.sender][tierId] += count;\n\n        // Initialize an array for the token IDs to be returned.\n        tokenIds = new uint256[](count);\n\n        // Keep a reference to the number of NFTs burned within the tier.\n        uint256 numberOfBurnedFromTier = numberOfBurnedFor[msg.sender][tierId];\n\n        for (uint256 i; i < count; i++) {\n            // Generate the NFTs.\n            tokenIds[i] = _generateTokenId(\n                tierId, storedTier.initialSupply - --storedTier.remainingSupply + numberOfBurnedFromTier\n            );\n        }\n    }\n\n    /// @notice Record tiers being removed.\n    /// @param tierIds The IDs of the tiers being removed.\n    function recordRemoveTierIds(uint256[] calldata tierIds) external override {\n        for (uint256 i; i < tierIds.length; i++) {\n            // Set the tier being iterated upon (0-indexed).\n            uint256 tierId = tierIds[i];\n\n            // Get a reference to the stored tier.\n            JBStored721Tier storage storedTier = _storedTierOf[msg.sender][tierId];\n\n            // Parse the flags.\n            (,,, bool cannotBeRemoved,) = _unpackBools(storedTier.packedBools);\n\n            // Make sure the tier can be removed.\n            if (cannotBeRemoved) revert JB721TiersHookStore_CantRemoveTier();\n\n            // Remove the tier by marking it as removed in the bitmap.\n            _removedTiersBitmapWordOf[msg.sender].removeTier(tierId);\n        }\n    }\n\n    /// @notice Records the setting of a discount for a tier.\n    /// @param tierId The ID of the tier to record a discount for.\n    /// @param discountPercent The new discount percent being applied.\n    function recordSetDiscountPercentOf(uint256 tierId, uint256 discountPercent) external override {\n        // Make sure the discount percent is within the bound.\n        if (discountPercent > JB721Constants.MAX_DISCOUNT_PERCENT) {\n            revert JB721TiersHookStore_DiscountPercentExceedsBounds(\n                discountPercent, JB721Constants.MAX_DISCOUNT_PERCENT\n            );\n        }\n\n        // Get a reference to the stored tier.\n        JBStored721Tier storage storedTier = _storedTierOf[msg.sender][tierId];\n\n        // Parse the flags.\n        (,,,, bool cannotIncreaseDiscountPercent) = _unpackBools(storedTier.packedBools);\n\n        // Make sure that increasing the discount is allowed for the tier.\n        if (discountPercent > storedTier.discountPercent && cannotIncreaseDiscountPercent) {\n            revert JB721TiersHookStore_DiscountPercentIncreaseNotAllowed(discountPercent, storedTier.discountPercent);\n        }\n\n        // Set the discount.\n        storedTier.discountPercent = uint8(discountPercent);\n    }\n\n    /// @notice Record a new encoded IPFS URI for a tier.\n    /// @param tierId The ID of the tier to set the encoded IPFS URI of.\n    /// @param encodedIPFSUri The encoded IPFS URI to set for the tier.\n    function recordSetEncodedIPFSUriOf(uint256 tierId, bytes32 encodedIPFSUri) external override {\n        encodedIPFSUriOf[msg.sender][tierId] = encodedIPFSUri;\n    }\n\n    /// @notice Record a newly set token URI resolver.\n    /// @param resolver The resolver to set.\n    function recordSetTokenUriResolver(IJB721TokenUriResolver resolver) external override {\n        tokenUriResolverOf[msg.sender] = resolver;\n    }\n\n    /// @notice Record an 721 transfer.\n    /// @param tierId The ID of the tier that the 721 being transferred belongs to.\n    /// @param from The address that the 721 is being transferred from.\n    /// @param to The address that the 721 is being transferred to.\n    function recordTransferForTier(uint256 tierId, address from, address to) external override {\n        // If this is not a mint,\n        if (from != address(0)) {\n            // then subtract the tier balance from the sender.\n            --tierBalanceOf[msg.sender][from][tierId];\n        }\n\n        // If this is not a burn,\n        if (to != address(0)) {\n            unchecked {\n                // then increase the tier balance for the receiver.\n                ++tierBalanceOf[msg.sender][to][tierId];\n            }\n        }\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Get the first tier ID from an 721 contract (when sorted by price) within a provided category.\n    /// @param hook The 721 contract to get the first sorted tier ID of.\n    /// @param category The category to get the first sorted tier ID within. Send 0 for the first ID across all tiers,\n    /// which might not be in the 0th category if the 0th category does not exist.\n    /// @return id The first sorted tier ID within the provided category.\n    function _firstSortedTierIdOf(address hook, uint256 category) internal view returns (uint256 id) {\n        id = category == 0 ? _tierIdAfter[hook][0] : _startingTierIdOfCategory[hook][category];\n        // Start at the first tier ID if nothing is specified.\n        if (id == 0) id = 1;\n    }\n\n    /// @notice Generate a token ID for an 721 given a tier ID and a token number within that tier.\n    /// @param tierId The ID of the tier to generate a token ID for.\n    /// @param tokenNumber The token number of the 721 within the tier.\n    /// @return The token ID of the 721.\n    function _generateTokenId(uint256 tierId, uint256 tokenNumber) internal pure returns (uint256) {\n        return (tierId * _ONE_BILLION) + tokenNumber;\n    }\n\n    /// @notice Returns the tier corresponding to the stored tier provided.\n    /// @dev Translate `JBStored721Tier` to `JB721Tier`.\n    /// @param hook The 721 contract to get the tier from.\n    /// @param tierId The ID of the tier to get.\n    /// @param storedTier The stored tier to get the corresponding tier for.\n    /// @param includeResolvedUri If set to `true`, if the contract has a token URI resolver, its content will be\n    /// resolved and included.\n    /// @return tier The tier as a `JB721Tier` struct.\n    function _getTierFrom(\n        address hook,\n        uint256 tierId,\n        JBStored721Tier memory storedTier,\n        bool includeResolvedUri\n    )\n        internal\n        view\n        returns (JB721Tier memory)\n    {\n        // Get a reference to the reserve beneficiary.\n        address reserveBeneficiary = reserveBeneficiaryOf(hook, tierId);\n\n        (\n            bool allowOwnerMint,\n            bool transfersPausable,\n            bool useVotingUnits,\n            bool cannotBeRemoved,\n            bool cannotIncreaseDiscountPercent\n        ) = _unpackBools(storedTier.packedBools);\n\n        // slither-disable-next-line calls-loop\n        return JB721Tier({\n            id: uint32(tierId),\n            price: storedTier.price,\n            remainingSupply: storedTier.remainingSupply,\n            initialSupply: storedTier.initialSupply,\n            votingUnits: useVotingUnits ? storedTier.votingUnits : storedTier.price,\n            // No reserve frequency if there is no reserve beneficiary.\n            reserveFrequency: reserveBeneficiary == address(0) ? 0 : storedTier.reserveFrequency,\n            reserveBeneficiary: reserveBeneficiary,\n            encodedIPFSUri: encodedIPFSUriOf[hook][tierId],\n            category: storedTier.category,\n            discountPercent: storedTier.discountPercent,\n            allowOwnerMint: allowOwnerMint,\n            transfersPausable: transfersPausable,\n            cannotBeRemoved: cannotBeRemoved,\n            cannotIncreaseDiscountPercent: cannotIncreaseDiscountPercent,\n            resolvedUri: !includeResolvedUri || tokenUriResolverOf[hook] == IJB721TokenUriResolver(address(0))\n                ? \"\"\n                : tokenUriResolverOf[hook].tokenUriOf(hook, _generateTokenId(tierId, 0))\n        });\n    }\n\n    /// @notice Check whether a tier has been removed while refreshing the relevant bitmap word if needed.\n    /// @param hook The 721 contract to check for removals on.\n    /// @param tierId The ID of the tier to check the removal status of.\n    /// @param bitmapWord The bitmap word to use.\n    /// @return A boolean which is `true` if the tier has been removed.\n    function _isTierRemovedWithRefresh(\n        address hook,\n        uint256 tierId,\n        JBBitmapWord memory bitmapWord\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // If the current tier ID is outside current bitmap word (depth), refresh the bitmap word.\n        if (bitmapWord.refreshBitmapNeeded(tierId) || (bitmapWord.currentWord == 0 && bitmapWord.currentDepth == 0)) {\n            bitmapWord = _removedTiersBitmapWordOf[hook].readId(tierId);\n        }\n\n        return bitmapWord.isTierIdRemoved(tierId);\n    }\n\n    /// @notice The last sorted tier ID from an 721 contract (when sorted by price).\n    /// @param hook The 721 contract to get the last sorted tier ID of.\n    /// @return id The last sorted tier ID.\n    function _lastSortedTierIdOf(address hook) internal view returns (uint256 id) {\n        id = _lastTrackedSortedTierIdOf[hook];\n        // Use the maximum tier ID if nothing is specified.\n        if (id == 0) id = maxTierIdOf[hook];\n    }\n\n    /// @notice Get the tier ID which comes after the provided one when sorted by price.\n    /// @param hook The 721 contract to get the next sorted tier ID from.\n    /// @param id The tier ID to get the next sorted tier ID relative to.\n    /// @param max The maximum tier ID.\n    /// @return The next sorted tier ID.\n    function _nextSortedTierIdOf(address hook, uint256 id, uint256 max) internal view returns (uint256) {\n        // If this is the last tier (maximum), return zero.\n        if (id == max) return 0;\n\n        // If a tier ID is saved to come after the provided ID, return it.\n        uint256 storedNext = _tierIdAfter[hook][id];\n\n        if (storedNext != 0) return storedNext;\n\n        // Otherwise, increment the provided tier ID.\n        return id + 1;\n    }\n\n    /// @notice Get the number of pending reserve NFTs for the specified tier ID.\n    /// @param hook The 721 contract that the tier belongs to.\n    /// @param tierId The ID of the tier to get the number of pending reserve NFTs for.\n    /// @param storedTier The stored tier to get the number of pending reserve NFTs for.\n    /// @return numberReservedTokensOutstanding The number of pending reserve NFTs for the tier.\n    function _numberOfPendingReservesFor(\n        address hook,\n        uint256 tierId,\n        JBStored721Tier memory storedTier\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        // Get a reference to the initial supply with burned NFTs included.\n        uint256 initialSupplyWithBurned = storedTier.initialSupply + numberOfBurnedFor[hook][tierId];\n\n        // No pending reserves if no mints, no reserve frequency, or no reserve beneficiary.\n        if (\n            storedTier.reserveFrequency == 0 || initialSupplyWithBurned == storedTier.remainingSupply\n                || reserveBeneficiaryOf(hook, tierId) == address(0)\n        ) return 0;\n\n        // The number of reserve NFTs which have already been minted from the tier.\n        uint256 numberOfReserveMints = numberOfReservesMintedFor[hook][tierId];\n\n        // If only the reserved 721 (from rounding up) has been minted so far, return 0.\n        if (initialSupplyWithBurned == storedTier.remainingSupply + numberOfReserveMints) {\n            return 0;\n        }\n\n        // Get a reference to the number of NFTs minted from the tier (not counting reserve mints or burned tokens).\n        uint256 numberOfNonReserveMints;\n        unchecked {\n            numberOfNonReserveMints = initialSupplyWithBurned - storedTier.remainingSupply - numberOfReserveMints;\n        }\n\n        // Get the number of total available reserve 721 mints given the number of non-reserve NFTs minted divided by\n        // the reserve frequency. This will round down.\n        uint256 totalNumberOfAvailableReserveMints = numberOfNonReserveMints / storedTier.reserveFrequency;\n\n        // Round up.\n        if (numberOfNonReserveMints % storedTier.reserveFrequency > 0) ++totalNumberOfAvailableReserveMints;\n\n        // Fill out the remaining supply with reserve NFTs if needed.\n        if (\n            (storedTier.initialSupply % storedTier.reserveFrequency) + totalNumberOfAvailableReserveMints\n                > storedTier.initialSupply\n        ) {\n            totalNumberOfAvailableReserveMints = storedTier.remainingSupply;\n        }\n\n        // Make sure there are more available reserve mints than actual reserve mints.\n        // This condition becomes possible if some NFTs have been burned.\n        if (numberOfReserveMints > totalNumberOfAvailableReserveMints) return 0;\n\n        // Return the difference between the number of available reserve mints and the amount already minted.\n        unchecked {\n            return totalNumberOfAvailableReserveMints - numberOfReserveMints;\n        }\n    }\n\n    /// @notice Pack three bools into a single uint8.\n    /// @param allowOwnerMint Whether or not owner minting is allowed in new tiers.\n    /// @param transfersPausable Whether or not 721 transfers can be paused.\n    /// @param useVotingUnits Whether or not custom voting unit amounts are allowed in new tiers.\n    /// @param cannotBeRemoved Whether or not attempts to remove the tier will revert.\n    /// @param cannotIncreaseDiscountPercent Whether or not attempts to increase the discount percent will revert.\n    /// @return packed The packed bools.\n    function _packBools(\n        bool allowOwnerMint,\n        bool transfersPausable,\n        bool useVotingUnits,\n        bool cannotBeRemoved,\n        bool cannotIncreaseDiscountPercent\n    )\n        internal\n        pure\n        returns (uint8 packed)\n    {\n        assembly {\n            packed := or(allowOwnerMint, packed)\n            packed := or(shl(0x1, transfersPausable), packed)\n            packed := or(shl(0x2, useVotingUnits), packed)\n            packed := or(shl(0x3, cannotBeRemoved), packed)\n            packed := or(shl(0x4, cannotIncreaseDiscountPercent), packed)\n        }\n    }\n\n    /// @notice Unpack three bools from a single uint8.\n    /// @param packed The packed bools.\n    /// @param allowOwnerMint Whether or not owner minting is allowed in new tiers.\n    /// @param transfersPausable Whether or not 721 transfers can be paused.\n    /// @param useVotingUnits Whether or not custom voting unit amounts are allowed in new tiers.\n    /// @param cannotBeRemoved Whether or not the tier can be removed once added.\n    /// @param cannotIncreaseDiscountPercent Whether or not the discount percent cannot be increased.\n    function _unpackBools(uint8 packed)\n        internal\n        pure\n        returns (\n            bool allowOwnerMint,\n            bool transfersPausable,\n            bool useVotingUnits,\n            bool cannotBeRemoved,\n            bool cannotIncreaseDiscountPercent\n        )\n    {\n        assembly {\n            allowOwnerMint := iszero(iszero(and(0x1, packed)))\n            transfersPausable := iszero(iszero(and(0x2, packed)))\n            useVotingUnits := iszero(iszero(and(0x4, packed)))\n            cannotBeRemoved := iszero(iszero(and(0x8, packed)))\n            cannotIncreaseDiscountPercent := iszero(iszero(and(0x10, packed)))\n        }\n    }\n}\n"
			},
			"src/interfaces/IJB721TiersHookStore.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJB721TokenUriResolver} from \"./IJB721TokenUriResolver.sol\";\nimport {JB721Tier} from \"../structs/JB721Tier.sol\";\nimport {JB721TierConfig} from \"../structs/JB721TierConfig.sol\";\nimport {JB721TiersHookFlags} from \"../structs/JB721TiersHookFlags.sol\";\n\ninterface IJB721TiersHookStore {\n    event CleanTiers(address indexed hook, address caller);\n\n    function balanceOf(address hook, address owner) external view returns (uint256);\n    function defaultReserveBeneficiaryOf(address hook) external view returns (address);\n    function encodedIPFSUriOf(address hook, uint256 tierId) external view returns (bytes32);\n    function encodedTierIPFSUriOf(address hook, uint256 tokenId) external view returns (bytes32);\n    function flagsOf(address hook) external view returns (JB721TiersHookFlags memory);\n    function isTierRemoved(address hook, uint256 tierId) external view returns (bool);\n    function maxTierIdOf(address hook) external view returns (uint256);\n    function numberOfBurnedFor(address hook, uint256 tierId) external view returns (uint256);\n    function numberOfPendingReservesFor(address hook, uint256 tierId) external view returns (uint256);\n    function numberOfReservesMintedFor(address hook, uint256 tierId) external view returns (uint256);\n    function cashOutWeightOf(address hook, uint256[] calldata tokenIds) external view returns (uint256 weight);\n    function reserveBeneficiaryOf(address hook, uint256 tierId) external view returns (address);\n    function tierBalanceOf(address hook, address owner, uint256 tier) external view returns (uint256);\n    function tierIdOfToken(uint256 tokenId) external pure returns (uint256);\n    function tierOf(address hook, uint256 id, bool includeResolvedUri) external view returns (JB721Tier memory tier);\n    function tierOfTokenId(\n        address hook,\n        uint256 tokenId,\n        bool includeResolvedUri\n    )\n        external\n        view\n        returns (JB721Tier memory tier);\n\n    function tiersOf(\n        address hook,\n        uint256[] calldata categories,\n        bool includeResolvedUri,\n        uint256 startingSortIndex,\n        uint256 size\n    )\n        external\n        view\n        returns (JB721Tier[] memory tiers);\n\n    function tierVotingUnitsOf(address hook, address account, uint256 tierId) external view returns (uint256 units);\n    function tokenUriResolverOf(address hook) external view returns (IJB721TokenUriResolver);\n    function totalCashOutWeight(address hook) external view returns (uint256 weight);\n    function totalSupplyOf(address hook) external view returns (uint256);\n    function votingUnitsOf(address hook, address account) external view returns (uint256 units);\n\n    function cleanTiers(address hook) external;\n    function recordAddTiers(JB721TierConfig[] calldata tierData) external returns (uint256[] memory tierIds);\n    function recordBurn(uint256[] calldata tokenIds) external;\n    function recordFlags(JB721TiersHookFlags calldata flag) external;\n    function recordMint(\n        uint256 amount,\n        uint16[] calldata tierIds,\n        bool isOwnerMint\n    )\n        external\n        returns (uint256[] memory tokenIds, uint256 leftoverAmount);\n    function recordMintReservesFor(uint256 tierId, uint256 count) external returns (uint256[] memory tokenIds);\n    function recordRemoveTierIds(uint256[] calldata tierIds) external;\n    function recordSetEncodedIPFSUriOf(uint256 tierId, bytes32 encodedIPFSUri) external;\n    function recordSetDiscountPercentOf(uint256 tierId, uint256 discountPercent) external;\n    function recordSetTokenUriResolver(IJB721TokenUriResolver resolver) external;\n    function recordTransferForTier(uint256 tierId, address from, address to) external;\n}\n"
			},
			"src/interfaces/IJB721TokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJB721TokenUriResolver {\n    function tokenUriOf(address nft, uint256 tokenId) external view returns (string memory tokenUri);\n}\n"
			},
			"src/libraries/JB721Constants.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across 721 hook contracts.\nlibrary JB721Constants {\n    uint16 public constant MAX_DISCOUNT_PERCENT = 200;\n}\n"
			},
			"src/libraries/JBBitmap.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {JBBitmapWord} from \"../structs/JBBitmapWord.sol\";\n\n/// @title JBBitmap\n/// @notice Utilities to manage a bool bitmap. Used for storing inactive tiers.\nlibrary JBBitmap {\n    /// @notice Initialize a `JBBitmapWord` struct based on a mapping storage pointer and an index.\n    function readId(\n        mapping(uint256 => uint256) storage self,\n        uint256 index\n    )\n        internal\n        view\n        returns (JBBitmapWord memory)\n    {\n        uint256 depth = _retrieveDepth(index);\n\n        return JBBitmapWord({currentWord: self[depth], currentDepth: depth});\n    }\n\n    /// @notice Get the status of the specified bit within the `JBBitmapWord` struct.\n    /// @dev The `index` is the index that the bit would have if the bitmap were reshaped to a 1*n matrix.\n    /// @return The boolean value at the specified index, which indicates whether the corresponding tier has been\n    /// removed.\n    function isTierIdRemoved(JBBitmapWord memory self, uint256 index) internal pure returns (bool) {\n        return (self.currentWord >> (index % 256)) & 1 == 1;\n    }\n\n    /// @notice Get the status of the specified bit within the `JBBitmapWord` struct.\n    /// @dev The `index` is the index that the bit would have if the bitmap were reshaped to a 1*n matrix.\n    function isTierIdRemoved(mapping(uint256 => uint256) storage self, uint256 index) internal view returns (bool) {\n        uint256 depth = _retrieveDepth(index);\n        return isTierIdRemoved(JBBitmapWord({currentWord: self[depth], currentDepth: depth}), index);\n    }\n\n    /// @notice Set the bit at the given index to true, indicating that the corresponding tier has been removed.\n    /// @dev This is a one-way operation.\n    function removeTier(mapping(uint256 => uint256) storage self, uint256 index) internal {\n        uint256 depth = _retrieveDepth(index);\n        self[depth] |= uint256(1 << (index % 256));\n    }\n\n    /// @notice Check if the specified index is at a different depth than than the current depth of the `JBBitmapWord`\n    /// struct.\n    /// @dev If the depth is different, the bitmap's current depth needs to be updated.\n    /// @return Whether the bitmap needs to be refreshed.\n    function refreshBitmapNeeded(JBBitmapWord memory self, uint256 index) internal pure returns (bool) {\n        return _retrieveDepth(index) != self.currentDepth;\n    }\n\n    /// @notice Return the line number (depth) of a given index within the bitmap matrix.\n    function _retrieveDepth(uint256 index) internal pure returns (uint256) {\n        return index >> 8; // div by 256\n    }\n}\n"
			},
			"src/structs/JB721Tier.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member id The tier's ID.\n/// @custom:member price The price to buy an NFT in this tier, in terms of the currency in its `JBInitTiersConfig`.\n/// @custom:member remainingSupply The remaining number of NFTs which can be minted from this tier.\n/// @custom:member initialSupply The total number of NFTs which can be minted from this tier.\n/// @custom:member votingUnits The number of votes that each NFT in this tier gets.\n/// @custom:member reserveFrequency The frequency at which an extra NFT is minted for the `reserveBeneficiary` from this\n/// tier. With a `reserveFrequency` of 5, an extra NFT will be minted for the `reserveBeneficiary` for every 5 NFTs\n/// purchased.\n/// @custom:member reserveBeneficiary The address which receives any reserve NFTs from this tier.\n/// @custom:member encodedIPFSUri The IPFS URI to use for each NFT in this tier.\n/// @custom:member category The category that NFTs in this tier belongs to. Used to group NFT tiers.\n/// @custom:member discountPercent The discount that should be applied to the tier.\n/// @custom:member allowOwnerMint A boolean indicating whether the contract's owner can mint NFTs from this tier\n/// on-demand.\n/// @custom:member cannotBeRemoved A boolean indicating whether attempts to remove this tier will revert.\n/// @custom:member cannotIncreaseDiscountPercent If the tier cannot have its discount increased.\n/// @custom:member transfersPausable A boolean indicating whether transfers for NFTs in tier can be paused.\n/// @custom:member resolvedUri A resolved token URI for NFTs in this tier. Only available if the NFT this tier belongs\n/// to has a resolver.\nstruct JB721Tier {\n    uint32 id;\n    uint104 price;\n    uint32 remainingSupply;\n    uint32 initialSupply;\n    uint104 votingUnits;\n    uint16 reserveFrequency;\n    address reserveBeneficiary;\n    bytes32 encodedIPFSUri;\n    uint24 category;\n    uint8 discountPercent;\n    bool allowOwnerMint;\n    bool transfersPausable;\n    bool cannotBeRemoved;\n    bool cannotIncreaseDiscountPercent;\n    string resolvedUri;\n}\n"
			},
			"src/structs/JB721TierConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Config for a single NFT tier within a `JB721TiersHook`.\n/// @custom:member price The price to buy an NFT in this tier, in terms of the currency in its `JBInitTiersConfig`.\n/// @custom:member initialSupply The total number of NFTs which can be minted from this tier.\n/// @custom:member votingUnits The number of votes that each NFT in this tier gets if `useVotingUnits` is true.\n/// @custom:member reserveFrequency The frequency at which an extra NFT is minted for the `reserveBeneficiary` from this\n/// tier. With a `reserveFrequency` of 5, an extra NFT will be minted for the `reserveBeneficiary` for every 5 NFTs\n/// purchased.\n/// @custom:member reserveBeneficiary The address which receives any reserve NFTs from this tier. Overrides the default\n/// reserve beneficiary if one is set.\n/// @custom:member encodedIPFSUri The IPFS URI to use for each NFT in this tier.\n/// @custom:member category The category that NFTs in this tier belongs to. Used to group NFT tiers.\n/// @custom:member discountPercent The discount that should be applied to the tier.\n/// @custom:member allowOwnerMint A boolean indicating whether the contract's owner can mint NFTs from this tier\n/// on-demand.\n/// @custom:member useReserveBeneficiaryAsDefault A boolean indicating whether this tier's `reserveBeneficiary` should\n/// be stored as the default beneficiary for all tiers.\n/// @custom:member transfersPausable A boolean indicating whether transfers for NFTs in tier can be paused.\n/// @custom:member useVotingUnits A boolean indicating whether the `votingUnits` should be used to calculate voting\n/// power. If `useVotingUnits` is false, voting power is based on the tier's price.\n/// @custom:member cannotBeRemoved If the tier cannot be removed once added.\n/// @custom:member cannotIncreaseDiscount If the tier cannot have its discount increased.\nstruct JB721TierConfig {\n    uint104 price;\n    uint32 initialSupply;\n    uint32 votingUnits;\n    uint16 reserveFrequency;\n    address reserveBeneficiary;\n    bytes32 encodedIPFSUri;\n    uint24 category;\n    uint8 discountPercent;\n    bool allowOwnerMint;\n    bool useReserveBeneficiaryAsDefault;\n    bool transfersPausable;\n    bool useVotingUnits;\n    bool cannotBeRemoved;\n    bool cannotIncreaseDiscountPercent;\n}\n"
			},
			"src/structs/JB721TiersHookFlags.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member noNewTiersWithReserves A boolean indicating whether attempts to add new tiers with a non-zero\n/// `reserveFrequency` will revert.\n/// @custom:member noNewTiersWithVotes A boolean indicating whether attempts to add new tiers with non-zero\n/// `votingUnits` will revert.\n/// @custom:member noNewTiersWithOwnerMinting A boolean indicating whether attempts to add new tiers with\n/// `allowOwnerMint` set to true will revert.\n/// @custom:member preventOverspending A boolean indicating whether payments attempting to spend more than the price of\n/// the NFTs being minted will revert.\nstruct JB721TiersHookFlags {\n    bool noNewTiersWithReserves;\n    bool noNewTiersWithVotes;\n    bool noNewTiersWithOwnerMinting;\n    bool preventOverspending;\n}\n"
			},
			"src/structs/JBBitmapWord.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @dev A \"word\" is a 256-bit integer that stores the status of 256 bits (true/false values). Each row of the\n/// `JBBitmap` matrix is a \"word\".\n/// @custom:member The information stored at the index.\n/// @custom:member The index.\nstruct JBBitmapWord {\n    uint256 currentWord;\n    uint256 currentDepth;\n}\n"
			},
			"src/structs/JBStored721Tier.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member price The price to buy an NFT in this tier, in terms of the currency in its `JBInitTiersConfig`.\n/// @custom:member remainingSupply The remaining number of NFTs which can be minted from this tier.\n/// @custom:member initialSupply The total number of NFTs which can be minted from this tier.\n/// @custom:member votingUnits The number of votes that each NFT in this tier gets.\n/// @custom:member category The category that NFTs in this tier belongs to. Used to group NFT tiers.\n/// @custom:member discountPercent The discount that should be applied to the tier.\n/// @custom:member reserveFrequency The frequency at which an extra NFT is minted for the `reserveBeneficiary` from this\n/// tier. With a `reserveFrequency` of 5, an extra NFT will be minted for the `reserveBeneficiary` for every 5 NFTs\n/// purchased.\n/// @custom:member allowOwnerMint A boolean indicating whether the contract's owner can mint NFTs from this tier\n/// on-demand.\n/// @custom:member transfersPausable A boolean indicating whether transfers for NFTs in tier can be paused.\n/// @custom:member useVotingUnits A boolean indicating whether the `votingUnits` should be used to calculate voting\n/// power. If `useVotingUnits` is false, voting power is based on the tier's price.\nstruct JBStored721Tier {\n    uint104 price;\n    uint32 remainingSupply;\n    uint32 initialSupply;\n    uint32 votingUnits;\n    uint24 category;\n    uint8 discountPercent;\n    uint16 reserveFrequency;\n    uint8 packedBools;\n}\n"
			},
			"node_modules/@bananapus/core/src/abstract/JBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBPermissioned} from \"./../interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./../interfaces/IJBPermissions.sol\";\n\n/// @notice Modifiers to allow access to transactions based on which permissions the message's sender has.\nabstract contract JBPermissioned is Context, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n\n    error JBPermissioned_Unauthorized(address account, address sender, uint256 projectId, uint256 permissionId);\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    constructor(IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Require the message sender to be the account or have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view {\n        address sender = _msgSender();\n        if (\n            sender != account\n                && !PERMISSIONS.hasPermission({\n                    operator: sender,\n                    account: account,\n                    projectId: projectId,\n                    permissionId: permissionId,\n                    includeRoot: true,\n                    includeWildcardProjectId: true\n                })\n        ) revert JBPermissioned_Unauthorized(account, sender, projectId, permissionId);\n    }\n\n    /// @notice If the 'alsoGrantAccessIf' condition is truthy, proceed. Otherwise, require the message sender to be the\n    /// account or\n    /// have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n    {\n        if (alsoGrantAccessIf) return;\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/enums/JBApprovalStatus.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBCashOutHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterCashOutRecordedContext} from \"./../structs/JBAfterCashOutRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `cashOutTokensOf(...)` logic completes (if passed by the ruleset's data\n/// hook).\ninterface IJBCashOutHook is IERC165 {\n    /// @notice This function is called by the terminal's `cashOutTokensOf(...)` function after the cash out has been\n    /// recorded in the terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterCashOutRecordedContext` struct.\n    function afterCashOutRecordedWith(JBAfterCashOutRecordedContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBDirectory {\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed isAllowed, address caller);\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPayHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"./IJBPermissions.sol\";\n\ninterface IJBPermissioned {\n    function PERMISSIONS() external view returns (IJBPermissions);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPermissionsData} from \"./../structs/JBPermissionsData.sol\";\n\ninterface IJBPermissions {\n    event OperatorPermissionsSet(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed projectId,\n        uint8[] permissionIds,\n        uint256 packed,\n        address caller\n    );\n\n    function WILDCARD_PROJECT_ID() external view returns (uint256);\n\n    function permissionsOf(address operator, address account, uint256 projectId) external view returns (uint256);\n\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPriceFeed.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBPriceFeed {\n    function currentUnitPrice(uint256 targetDecimals) external view returns (uint256);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPrices.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBPrices {\n    event AddPriceFeed(\n        uint256 indexed projectId,\n        uint256 indexed pricingCurrency,\n        uint256 indexed unitCurrency,\n        IJBPriceFeed feed,\n        address caller\n    );\n\n    function DEFAULT_PROJECT_ID() external view returns (uint256);\n    function PROJECTS() external view returns (IJBProjects);\n\n    function priceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency\n    )\n        external\n        view\n        returns (IJBPriceFeed);\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        external\n        view\n        returns (uint256);\n\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n    function setTokenUriResolver(IJBTokenUriResolver resolver) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\n/// @notice `IJBRulesetApprovalHook`s are used to determine whether the next ruleset in the ruleset queue is approved or\n/// rejected.\n/// @dev Project rulesets are stored in a queue. Rulesets take effect after the previous ruleset in the queue ends, and\n/// only if they are approved by the previous ruleset's approval hook.\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 start\n    )\n        external\n        view\n        returns (JBApprovalStatus);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesetDataHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBBeforePayRecordedContext} from \"./../structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeCashOutRecordedContext} from \"./../structs/JBBeforeCashOutRecordedContext.sol\";\nimport {JBCashOutHookSpecification} from \"./../structs/JBCashOutHookSpecification.sol\";\nimport {JBPayHookSpecification} from \"./../structs/JBPayHookSpecification.sol\";\n\n/// @notice Data hooks can extend a terminal's core pay/cashout functionality by overriding the weight or memo. They can\n/// also specify pay/cashout hooks for the terminal to fulfill, or allow addresses to mint a project's tokens on-demand.\n/// @dev If a project's ruleset has `useDataHookForPay` or `useDataHookForCashOut` enabled, its `dataHook` is called by\n/// the terminal upon payments/cashouts (respectively).\ninterface IJBRulesetDataHook is IERC165 {\n    /// @notice A flag indicating whether an address has permission to mint a project's tokens on-demand.\n    /// @dev A project's data hook can allow any address to mint its tokens.\n    /// @param projectId The ID of the project whose token can be minted.\n    /// @param addr The address to check the token minting permission of.\n    /// @return flag A flag indicating whether the address has permission to mint the project's tokens on-demand.\n    function hasMintPermissionFor(uint256 projectId, address addr) external view returns (bool flag);\n\n    /// @notice The data calculated before a payment is recorded in the terminal store. This data is provided to the\n    /// terminal's `pay(...)` transaction.\n    /// @param context The context passed to this data hook by the `pay(...)` function as a `JBBeforePayRecordedContext`\n    /// struct.\n    /// @return weight The new `weight` to use, overriding the ruleset's `weight`.\n    /// @return hookSpecifications The amount and data to send to pay hooks instead of adding to the terminal's balance.\n    function beforePayRecordedWith(JBBeforePayRecordedContext calldata context)\n        external\n        view\n        returns (uint256 weight, JBPayHookSpecification[] memory hookSpecifications);\n\n    /// @notice The data calculated before a cash out is recorded in the terminal store. This data is provided to the\n    /// terminal's `cashOutTokensOf(...)` transaction.\n    /// @param context The context passed to this data hook by the `cashOutTokensOf(...)` function as a\n    /// `JBBeforeCashOutRecordedContext` struct.\n    /// @return cashOutTaxRate The rate determining the amount that should be reclaimable for a given surplus and token\n    /// supply.\n    /// @return cashOutCount The amount of tokens that should be considered cashed out.\n    /// @return totalSupply The total amount of tokens that are considered to be existing.\n    /// @return hookSpecifications The amount and data to send to cash out hooks instead of returning to the\n    /// beneficiary.\n    function beforeCashOutRecordedWith(JBBeforeCashOutRecordedContext calldata context)\n        external\n        view\n        returns (\n            uint256 cashOutTaxRate,\n            uint256 cashOutCount,\n            uint256 totalSupply,\n            JBCashOutHookSpecification[] memory hookSpecifications\n        );\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBRulesets.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets {\n    event RulesetInitialized(\n        uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId, address caller\n    );\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    event WeightCacheUpdated(uint256 projectId, uint112 weight, uint256 weightCutMultiple, address caller);\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n    function deriveCycleNumberFrom(\n        uint256 baseRulesetCycleNumber,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 start\n    )\n        external\n        returns (uint256);\n    function deriveStartFrom(\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        view\n        returns (uint256 start);\n    function deriveWeightFrom(\n        uint256 projectId,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 baseRulesetWeight,\n        uint256 baseRulesetWeightCutPercent,\n        uint256 baseRulesetCacheId,\n        uint256 start\n    )\n        external\n        view\n        returns (uint256 weight);\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n    function allOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n    function upcomingOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBPayHook} from \"./IJBPayHook.sol\";\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 returnedFees, string memo, bytes metadata, address caller\n    );\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 newlyIssuedTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n    event SetAccountingContext(uint256 indexed projectId, JBAccountingContext context, address caller);\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n    function currentSurplusOf(\n        uint256 projectId,\n        JBAccountingContext[] memory accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function addAccountingContextsFor(uint256 projectId, JBAccountingContext[] calldata accountingContexts) external;\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBConstants.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary JBConstants {\n    /// @notice Each chain's native token address in Juicebox is represented by\n    /// 0x000000000000000000000000000000000000EEEe.\n    address public constant NATIVE_TOKEN = address(0x000000000000000000000000000000000000EEEe);\n    uint16 public constant MAX_RESERVED_PERCENT = 10_000;\n    uint16 public constant MAX_CASH_OUT_TAX_RATE = 10_000;\n    uint32 public constant MAX_WEIGHT_CUT_PERCENT = 1_000_000_000;\n    uint32 public constant SPLITS_TOTAL_PERCENT = 1_000_000_000;\n    uint16 public constant MAX_FEE = 1000;\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBMetadataResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice Library to parse and create metadata to store {id: data} entries.\n *\n * @dev    Metadata are built as:\n *         - 32B of reserved space for the protocol\n *         - a lookup table `Id: offset`, defining the offset of the data for a given 4 bytes id.\n *           The offset fits 1 bytes, the ID 4 bytes. This table is padded to 32B.\n *         - the data for each id, padded to 32B each\n *\n *            +-----------------------+ offset: 0\n *            | 32B reserved          |\n *            +-----------------------+ offset: 1 = end of first 32B\n *            |      (ID1,offset1)    |\n *            |      (ID2,offset2)    |\n *            |       0's padding     |\n *            +-----------------------+ offset: offset1 = 1 + number of words taken by the padded table\n *            |       id1 data1       |\n *            | 0's padding           |\n *            +-----------------------+ offset: offset2 = offset1 + number of words taken by the data1\n *            |       id2 data2       |\n *            | 0's padding           |\n *            +-----------------------+\n */\nlibrary JBMetadataResolver {\n    error JBMetadataResolver_DataNotPadded();\n    error JBMetadataResolver_LengthMismatch();\n    error JBMetadataResolver_MetadataTooLong();\n    error JBMetadataResolver_MetadataTooShort();\n\n    // The various sizes used in bytes.\n    uint256 constant ID_SIZE = 4;\n    uint256 constant ID_OFFSET_SIZE = 1;\n    uint256 constant WORD_SIZE = 32;\n\n    // The size that an ID takes in the lookup table (Identifier + Offset).\n    uint256 constant TOTAL_ID_SIZE = 5; // ID_SIZE + ID_OFFSET_SIZE;\n\n    // The amount of bytes to go forward to get to the offset of the next ID (aka. the end of the offset of the current\n    // ID).\n    uint256 constant NEXT_ID_OFFSET = 9; // TOTAL_ID_SIZE + ID_SIZE;\n\n    // 1 word (32B) is reserved for the protocol .\n    uint256 constant RESERVED_SIZE = 32; // 1 * WORD_SIZE;\n    uint256 constant MIN_METADATA_LENGTH = 37; // RESERVED_SIZE + ID_SIZE + ID_OFFSET_SIZE;\n\n    /// @notice Add an {id: data} entry to an existing metadata. This is an append-only mechanism.\n    /// @param originalMetadata The original metadata\n    /// @param idToAdd The id to add\n    /// @param dataToAdd The data to add\n    /// @return newMetadata The new metadata with the entry added\n    function addToMetadata(\n        bytes memory originalMetadata,\n        bytes4 idToAdd,\n        bytes memory dataToAdd\n    )\n        internal\n        pure\n        returns (bytes memory newMetadata)\n    {\n        // Empty original metadata and maybe something in the first 32 bytes: create new metadata\n        if (originalMetadata.length <= RESERVED_SIZE) {\n            return abi.encodePacked(bytes32(originalMetadata), bytes32(abi.encodePacked(idToAdd, uint8(2))), dataToAdd);\n        }\n\n        // There is something in the table offset, but not a valid entry - avoid overwriting\n        if (originalMetadata.length < RESERVED_SIZE + ID_SIZE + 1) revert JBMetadataResolver_MetadataTooShort();\n\n        // Make sure the data is padded to 32 bytes.\n        if (dataToAdd.length < 32) revert JBMetadataResolver_DataNotPadded();\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)...\n        uint256 firstOffset = uint8(originalMetadata[RESERVED_SIZE + ID_SIZE]);\n\n        // ...go back to the beginning of the previous word (ie the last word of the table, as it can be padded)\n        uint256 lastWordOfTable = firstOffset - 1;\n\n        // The last offset stored in the table and its index\n        uint256 lastOffset;\n\n        // The number of words taken by the last data stored\n        uint256 numberOfWordslastData;\n\n        // Iterate to find the last entry of the table, lastOffset - we start from the end as the first value\n        // encountered\n        // will be the last offset\n        for (uint256 i = firstOffset * WORD_SIZE - 1; i > lastWordOfTable * WORD_SIZE - 1; i--) {\n            // If the byte is not 0, this is the last offset we're looking for\n            if (originalMetadata[i] != 0) {\n                lastOffset = uint8(originalMetadata[i]);\n                uint256 lastOffsetIndex = i;\n\n                // No rounding as this should be padded to 32B\n                numberOfWordslastData = (originalMetadata.length - lastOffset * WORD_SIZE) / WORD_SIZE;\n\n                // Copy the reserved word and the table and remove the previous padding\n                newMetadata = _sliceBytes(originalMetadata, 0, lastOffsetIndex + 1);\n\n                // Check if the new entry is still fitting in this word\n                if (i + TOTAL_ID_SIZE >= firstOffset * WORD_SIZE) {\n                    // Increment every offset by 1 (as the table now takes one more word)\n                    for (uint256 j = RESERVED_SIZE + ID_SIZE; j < lastOffsetIndex + 1; j += TOTAL_ID_SIZE) {\n                        newMetadata[j] = bytes1(uint8(originalMetadata[j]) + 1);\n                    }\n\n                    // Increment the last offset so the new offset will be properly set too\n                    lastOffset++;\n                }\n\n                break;\n            }\n        }\n\n        // Add the new entry after the last entry of the table, the new offset is the last offset + the number of words\n        // taken by the last data\n        newMetadata = abi.encodePacked(newMetadata, idToAdd, bytes1(uint8(lastOffset + numberOfWordslastData)));\n\n        // Pad as needed - inlined for gas saving\n        uint256 paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Add existing data at the end\n        newMetadata = abi.encodePacked(\n            newMetadata, _sliceBytes(originalMetadata, firstOffset * WORD_SIZE, originalMetadata.length)\n        );\n\n        // Pad as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Append new data at the end\n        newMetadata = abi.encodePacked(newMetadata, dataToAdd);\n\n        // Pad again again as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n    }\n\n    /// @notice Create the metadata for a list of {id:data}\n    /// @dev Intended for offchain use (gas heavy)\n    /// @param ids The list of ids\n    /// @param datas The list of corresponding datas\n    /// @return metadata The resulting metadata\n    function createMetadata(bytes4[] memory ids, bytes[] memory datas) internal pure returns (bytes memory metadata) {\n        if (ids.length != datas.length) revert JBMetadataResolver_LengthMismatch();\n\n        // Add a first empty 32B for the protocol reserved word\n        metadata = abi.encodePacked(bytes32(0));\n\n        // First offset for the data is after the first reserved word...\n        uint256 offset = 1;\n\n        // ... and after the id/offset lookup table, rounding up to 32 bytes words if not a multiple\n        offset += ((ids.length * JBMetadataResolver.TOTAL_ID_SIZE) - 1) / JBMetadataResolver.WORD_SIZE + 1;\n\n        // Keep a reference to the number of ids.\n        uint256 numberOfIds = ids.length;\n\n        // For each id, add it to the lookup table with the next free offset, then increment the offset by the data\n        // length (rounded up)\n        for (uint256 i; i < numberOfIds; ++i) {\n            // Set the data being iterated on.\n            bytes memory data = datas[i];\n\n            if (data.length < 32 || data.length % JBMetadataResolver.WORD_SIZE != 0) {\n                revert JBMetadataResolver_DataNotPadded();\n            }\n\n            metadata = abi.encodePacked(metadata, ids[i], bytes1(uint8(offset)));\n            offset += data.length / JBMetadataResolver.WORD_SIZE;\n\n            // Overflowing a bytes1?\n            if (offset > 255) revert JBMetadataResolver_MetadataTooLong();\n        }\n\n        // Pad the table to a multiple of 32B\n        uint256 paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n            ? metadata.length\n            : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n        assembly {\n            mstore(metadata, paddedLength)\n        }\n\n        // Keep a reference to the number of datas.\n        uint256 numberOfDatas = datas.length;\n\n        // Add each metadata to the array, each padded to 32 bytes\n        for (uint256 i; i < numberOfDatas; i++) {\n            metadata = abi.encodePacked(metadata, datas[i]);\n            paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n                ? metadata.length\n                : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n\n            assembly {\n                mstore(metadata, paddedLength)\n            }\n        }\n    }\n\n    /// @notice Parse the metadata to find the data for a specific ID\n    /// @dev Returns false and an empty bytes if no data is found\n    /// @param id The ID to find.\n    /// @param metadata The metadata to parse.\n    /// @return found Whether the {id:data} was found\n    /// @return targetData The data for the ID (can be empty)\n    function getDataFor(bytes4 id, bytes memory metadata) internal pure returns (bool found, bytes memory targetData) {\n        // Either no data or empty one with only one selector (32+4+1)\n        if (metadata.length <= MIN_METADATA_LENGTH) return (false, \"\");\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)\n        uint256 firstOffset = uint8(metadata[RESERVED_SIZE + ID_SIZE]);\n\n        // Parse the id's to find id, stop when next offset == 0 or current = first offset\n        for (uint256 i = RESERVED_SIZE; metadata[i + ID_SIZE] != bytes1(0) && i < firstOffset * WORD_SIZE;) {\n            // Set the current offset.\n            uint256 currentOffset = uint256(uint8(metadata[i + ID_SIZE]));\n\n            bytes4 parsedId;\n            assembly {\n                parsedId := mload(add(add(metadata, 0x20), i))\n            }\n\n            // _id found?\n            if (parsedId == id) {\n                // Are we at the end of the lookup table (either at the start of data's or next offset is 0/in the\n                // padding)\n                // If not, only return until from this offset to the begining of the next offset\n                uint256 end = (i + NEXT_ID_OFFSET >= firstOffset * WORD_SIZE || metadata[i + NEXT_ID_OFFSET] == 0)\n                    ? metadata.length\n                    : uint256(uint8(metadata[i + NEXT_ID_OFFSET])) * WORD_SIZE;\n\n                return (true, _sliceBytes(metadata, currentOffset * WORD_SIZE, end));\n            }\n            unchecked {\n                i += TOTAL_ID_SIZE;\n            }\n        }\n    }\n\n    /// @notice Returns an unique id following a suggested format (`xor(address(this), purpose name)` where purpose name\n    /// is a string giving context to the id (Permit2, quoteForSwap, etc)\n    /// @param purpose A string describing the purpose associated with the id\n    /// @return id The resulting ID.\n    function getId(string memory purpose) internal view returns (bytes4) {\n        return getId(purpose, address(this));\n    }\n\n    /// @notice Returns an unique id following a suggested format (`xor(address(this), purpose name)` where purpose name\n    /// is a string giving context to the id (Permit2, quoteForSwap, etc)\n    /// @param purpose A string describing the purpose associated with the id\n    /// @param target The target which will use the metadata\n    /// @return id The resulting ID.\n    function getId(string memory purpose, address target) internal pure returns (bytes4) {\n        return bytes4(bytes20(target) ^ bytes20(keccak256(bytes(purpose))));\n    }\n\n    /// @notice Slice bytes from a start index to an end index.\n    /// @param data The bytes array to slice\n    /// @param start The start index to slice at.\n    /// @param end The end index to slice at.\n    /// @param slicedBytes The sliced array.\n    function _sliceBytes(\n        bytes memory data,\n        uint256 start,\n        uint256 end\n    )\n        private\n        pure\n        returns (bytes memory slicedBytes)\n    {\n        assembly {\n            let length := sub(end, start)\n\n            // Allocate memory at the freemem(add 0x20 to include the length)\n            slicedBytes := mload(0x40)\n            mstore(0x40, add(add(slicedBytes, length), 0x20))\n\n            // Store the length (first element)\n            mstore(slicedBytes, length)\n\n            // compute the actual data first offset only once\n            let startBytes := add(add(data, 0x20), start)\n\n            // same for the out array\n            let sliceBytesStartOfData := add(slicedBytes, 0x20)\n\n            // store dem data\n            for { let i := 0 } lt(i, end) { i := add(i, 0x20) } {\n                mstore(add(sliceBytesStartOfData, i), mload(add(startBytes, i)))\n            }\n        }\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/libraries/JBRulesetMetadataResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\n\nlibrary JBRulesetMetadataResolver {\n    function reservedPercent(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 4);\n    }\n\n    function cashOutTaxRate(JBRuleset memory ruleset) internal pure returns (uint16) {\n        // Cash out tax rate is a number 0-10000.\n        return uint16(ruleset.metadata >> 20);\n    }\n\n    function baseCurrency(JBRuleset memory ruleset) internal pure returns (uint32) {\n        // Currency is a number 0-4294967296.\n        return uint32(ruleset.metadata >> 36);\n    }\n\n    function pausePay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 68) & 1) == 1;\n    }\n\n    function pauseCreditTransfers(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 69) & 1) == 1;\n    }\n\n    function allowOwnerMinting(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 70) & 1) == 1;\n    }\n\n    function allowSetCustomToken(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 71) & 1) == 1;\n    }\n\n    function allowTerminalMigration(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 72) & 1) == 1;\n    }\n\n    function allowSetTerminals(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 73) & 1) == 1;\n    }\n\n    function allowSetController(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 74) & 1) == 1;\n    }\n\n    function allowAddAccountingContext(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 75) & 1) == 1;\n    }\n\n    function allowAddPriceFeed(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 76) & 1) == 1;\n    }\n\n    function ownerMustSendPayouts(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 77) & 1) == 1;\n    }\n\n    function holdFees(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 78) & 1) == 1;\n    }\n\n    function useTotalSurplusForCashOuts(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 79) & 1) == 1;\n    }\n\n    function useDataHookForPay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 80) & 1 == 1;\n    }\n\n    function useDataHookForCashOut(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 81) & 1 == 1;\n    }\n\n    function dataHook(JBRuleset memory ruleset) internal pure returns (address) {\n        return address(uint160(ruleset.metadata >> 82));\n    }\n\n    function metadata(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 242);\n    }\n\n    /// @notice Pack the funding cycle metadata.\n    /// @param rulesetMetadata The ruleset metadata to validate and pack.\n    /// @return packed The packed uint256 of all metadata params. The first 8 bits specify the version.\n    function packRulesetMetadata(JBRulesetMetadata memory rulesetMetadata) internal pure returns (uint256 packed) {\n        // version 1 in the bits 0-3 (4 bits).\n        packed = 1;\n        // reserved percent in bits 4-19 (16 bits).\n        packed |= uint256(rulesetMetadata.reservedPercent) << 4;\n        // cash out tax rate in bits 20-35 (16 bits).\n        // cash out tax rate is a number 0-10000.\n        packed |= uint256(rulesetMetadata.cashOutTaxRate) << 20;\n        // base currency in bits 36-67 (32 bits).\n        // base currency is a number 0-16777215.\n        packed |= uint256(rulesetMetadata.baseCurrency) << 36;\n        // pause pay in bit 68.\n        if (rulesetMetadata.pausePay) packed |= 1 << 68;\n        // pause credit transfers in bit 69.\n        if (rulesetMetadata.pauseCreditTransfers) packed |= 1 << 69;\n        // allow discretionary minting in bit 70.\n        if (rulesetMetadata.allowOwnerMinting) packed |= 1 << 70;\n        // allow a custom token to be set in bit 71.\n        if (rulesetMetadata.allowSetCustomToken) packed |= 1 << 71;\n        // allow terminal migration in bit 72.\n        if (rulesetMetadata.allowTerminalMigration) packed |= 1 << 72;\n        // allow set terminals in bit 73.\n        if (rulesetMetadata.allowSetTerminals) packed |= 1 << 73;\n        // allow set controller in bit 74.\n        if (rulesetMetadata.allowSetController) packed |= 1 << 74;\n        // allow add accounting context in bit 75.\n        if (rulesetMetadata.allowAddAccountingContext) packed |= 1 << 75;\n        // allow add price feed in bit 76.\n        if (rulesetMetadata.allowAddPriceFeed) packed |= 1 << 76;\n        // allow controller migration in bit 77.\n        if (rulesetMetadata.ownerMustSendPayouts) packed |= 1 << 77;\n        // hold fees in bit 78.\n        if (rulesetMetadata.holdFees) packed |= 1 << 78;\n        // useTotalSurplusForCashOuts in bit 79.\n        if (rulesetMetadata.useTotalSurplusForCashOuts) packed |= 1 << 79;\n        // use pay data source in bit 80.\n        if (rulesetMetadata.useDataHookForPay) packed |= 1 << 80;\n        // use cash out data source in bit 81.\n        if (rulesetMetadata.useDataHookForCashOut) packed |= 1 << 81;\n        // data source address in bits 82-241.\n        packed |= uint256(uint160(address(rulesetMetadata.dataHook))) << 82;\n        // metadata in bits 242-255 (14 bits).\n        packed |= (uint256(rulesetMetadata.metadata) & 0x3FFF) << 242;\n    }\n\n    /// @notice Expand the funding cycle metadata.\n    /// @param ruleset The funding cycle having its metadata expanded.\n    /// @return rulesetMetadata The ruleset's metadata object.\n    function expandMetadata(JBRuleset memory ruleset) internal pure returns (JBRulesetMetadata memory) {\n        return JBRulesetMetadata(\n            reservedPercent(ruleset),\n            cashOutTaxRate(ruleset),\n            baseCurrency(ruleset),\n            pausePay(ruleset),\n            pauseCreditTransfers(ruleset),\n            allowOwnerMinting(ruleset),\n            allowSetCustomToken(ruleset),\n            allowTerminalMigration(ruleset),\n            allowSetTerminals(ruleset),\n            allowSetController(ruleset),\n            allowAddAccountingContext(ruleset),\n            allowAddPriceFeed(ruleset),\n            ownerMustSendPayouts(ruleset),\n            holdFees(ruleset),\n            useTotalSurplusForCashOuts(ruleset),\n            useDataHookForPay(ruleset),\n            useDataHookForCashOut(ruleset),\n            dataHook(ruleset),\n            metadata(ruleset)\n        );\n    }\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAccountingContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAfterCashOutRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member holder The holder of the tokens being cashed out.\n/// @custom:member projectId The ID of the project being cashed out from.\n/// @custom:member rulesetId The ID of the ruleset the cash out is being made during.\n/// @custom:member cashOutCount The number of project tokens being cashed out.\n/// @custom:member cashOutTaxRate The current ruleset's cash out tax rate.\n/// @custom:member reclaimedAmount The token amount being reclaimed from the project's terminal balance. Includes the\n/// token being\n/// reclaimed, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the cash out hook. Includes the token\n/// being forwarded, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member beneficiary The address the reclaimed amount will be sent to.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the cash out hook.\n/// @custom:member cashOutMetadata Extra data specified by the account cashing out, which is sent to the cash out hook.\nstruct JBAfterCashOutRecordedContext {\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 cashOutCount;\n    JBTokenAmount reclaimedAmount;\n    JBTokenAmount forwardedAmount;\n    uint256 cashOutTaxRate;\n    address payable beneficiary;\n    bytes hookMetadata;\n    bytes cashOutMetadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBAfterPayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member newlyIssuedTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 newlyIssuedTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBBeforeCashOutRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon cash out.\n/// @custom:member terminal The terminal that is facilitating the cash out.\n/// @custom:member holder The holder of the tokens being cashed out.\n/// @custom:member projectId The ID of the project whose tokens are being cashed out.\n/// @custom:member rulesetId The ID of the ruleset the cash out is being made during.\n/// @custom:member cashOutCount The number of tokens being cashed out, as a fixed point number with 18 decimals.\n/// @custom:member totalSupply The total token supply being used for the calculation, as a fixed point number with 18\n/// decimals.\n/// @custom:member surplus The surplus amount used for the calculation, as a fixed point number with 18 decimals.\n/// Includes the token of the surplus, the surplus value, the number of decimals\n/// included, and the currency of the surplus.\n/// @custom:member useTotalSurplus If surplus across all of a project's terminals is being used when making cash outs.\n/// @custom:member cashOutTaxRate The cash out tax rate of the ruleset the cash out is being made during.\n/// @custom:member metadata Extra data provided by the casher.\nstruct JBBeforeCashOutRecordedContext {\n    address terminal;\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 cashOutCount;\n    uint256 totalSupply;\n    JBTokenAmount surplus;\n    bool useTotalSurplus;\n    uint256 cashOutTaxRate;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBBeforePayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon payment.\n/// @custom:member terminal The terminal that is facilitating the payment.\n/// @custom:member payer The address that the payment originated from.\n/// @custom:member amount The payment's token amount, including the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member beneficiary The specified address that should be the beneficiary of anything that this payment\n/// yields.\n/// @custom:member weight The weight of the ruleset during which the payment is being made.\n/// @custom:member reservedPercent The reserved percent of the ruleset the payment is being made during.\n/// @custom:member metadata Extra data specified by the payer.\nstruct JBBeforePayRecordedContext {\n    address terminal;\n    address payer;\n    JBTokenAmount amount;\n    uint256 projectId;\n    uint256 rulesetId;\n    address beneficiary;\n    uint256 weight;\n    uint256 reservedPercent;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBCashOutHookSpecification.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBCashOutHook} from \"../interfaces/IJBCashOutHook.sol\";\n\n/// @notice A cash out hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The cash out hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass to the hook.\nstruct JBCashOutHookSpecification {\n    IJBCashOutHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBPayHookSpecification.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPayHook} from \"../interfaces/IJBPayHook.sol\";\n\n/// @notice A pay hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The pay hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass the hook.\nstruct JBPayHookSpecification {\n    IJBPayHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member operator The address that permissions are being given to.\n/// @custom:member projectId The ID of the project the operator is being given permissions for. Operators only have\n/// permissions under this project's scope. An ID of 0 is a wildcard, which gives an operator permissions across all\n/// projects.\n/// @custom:member permissionIds The IDs of the permissions being given. See the `JBPermissionIds` library.\nstruct JBPermissionsData {\n    address operator;\n    uint56 projectId;\n    uint8[] permissionIds;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRuleset.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `weightCutPercent`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member weightCutPercent The percentage by which to reduce the `weight` each time a new ruleset starts.\n/// `weight`\n/// is\n/// a percentage out of `JBConstants.MAX_WEIGHT_CUT_PERCENT`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `weightCutPercent` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint48 cycleNumber;\n    uint48 id;\n    uint48 basedOnId;\n    uint48 start;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedPercent The reserved percent of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_PERCENT`.\n/// @custom:member cashOutTaxRate The cash out tax rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_CASH_OUT_TAX_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member allowAddAccountingContext A flag indicating if a project can add new accounting contexts for its\n/// terminals to use.\n/// @custom:member allowAddPriceFeed A flag indicating if a project can add new price feeds to calculate exchange rates\n/// between its tokens.\n/// @custom:member ownerMustSendPayouts A flag indicating if privileged payout distribution should be\n/// enforced, otherwise payouts can be distributed by anyone.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForCashOuts A flag indicating if cash outs should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the cash out is being fulfilled.\n/// @custom:member useDataHookForPay A flag indicating if the data hook should be used for pay transactions during this\n/// ruleset.\n/// @custom:member useDataHookForCashOut A flag indicating if the data hook should be used for cash out transactions\n/// during\n/// this ruleset.\n/// @custom:member dataHook The data hook to use during this ruleset.\n/// @custom:member metadata Metadata of the metadata, only the 14 least significant bits can be used, the 2 most\n/// significant bits are disregarded.\nstruct JBRulesetMetadata {\n    uint16 reservedPercent;\n    uint16 cashOutTaxRate;\n    uint32 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowSetCustomToken;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowSetController;\n    bool allowAddAccountingContext;\n    bool allowAddPriceFeed;\n    bool ownerMustSendPayouts;\n    bool holdFees;\n    bool useTotalSurplusForCashOuts;\n    bool useDataHookForPay;\n    bool useDataHookForCashOut;\n    address dataHook;\n    uint16 metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTokenAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\nstruct JBTokenAmount {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n    uint256 value;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\n\nimport {JBOwnableOverrides} from \"./JBOwnableOverrides.sol\";\n\ncontract JBOwnable is JBOwnableOverrides {\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param initialProjectIdOwner The initial project id that owns this contract.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        address initialOwner,\n        uint88 initialProjectIdOwner\n    )\n        JBOwnableOverrides(permissions, projects, initialOwner, initialProjectIdOwner)\n    {}\n\n    //*********************************************************************//\n    // --------------------------- modifiers ----------------------------- //\n    //*********************************************************************//\n\n    /// @notice Reverts if called by an address that is not the owner and does not have permission from the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Either `newOwner` or `newProjectId` is non-zero or both are zero. But they can never both be non-zero.\n    /// @dev This function exists because some contracts will try to deploy contracts for a project before\n    function _emitTransferEvent(\n        address previousOwner,\n        address newOwner,\n        uint88 newProjectId\n    )\n        internal\n        virtual\n        override\n    {\n        emit OwnershipTransferred({\n            previousOwner: previousOwner,\n            newOwner: newProjectId == 0 ? newOwner : PROJECTS.ownerOf(newProjectId),\n            caller: msg.sender\n        });\n    }\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnableOverrides.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBOwnable} from \"./interfaces/IJBOwnable.sol\";\nimport {JBOwner} from \"./struct/JBOwner.sol\";\n\n/// @notice Access control module to grant exclusive access to a specified address (the owner) for specific functions.\n/// The owner can also grant access permissions to other addresses via `JBPermissions`.\n/// @dev Inherit this contract to make the `onlyOwner` modifier available. When applied to a function, this modifier\n/// restricts use to the owner and addresses with the appropriate permission from the owner.\nabstract contract JBOwnableOverrides is Context, JBPermissioned, IJBOwnable {\n    //*********************************************************************//\n    // --------------------------- custom errors --------------------------//\n    //*********************************************************************//b\n\n    error JBOwnableOverrides_InvalidNewOwner();\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice This contract's owner information.\n    JBOwner public override jbOwner;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param initialProjectIdOwner The initial project id that owns this contract.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        address initialOwner,\n        uint88 initialProjectIdOwner\n    )\n        JBPermissioned(permissions)\n    {\n        PROJECTS = projects;\n\n        // We force the inheriting contract to set an owner, as there is a\n        // low chance someone will use `JBOwnable` to create an unowned contract.\n        // But a higher chance that both are accidentally set to be `0`.\n        // If you really want an unowned contract, set the owner to any address then renounce in the constructor body.\n        if (initialProjectIdOwner == 0 && initialOwner == address(0)) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n\n        _transferOwnership(initialOwner, initialProjectIdOwner);\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns the owner's address based on this contract's `JBOwner` owner information.\n    /// @return owner The owner's address.\n    function owner() public view virtual returns (address) {\n        JBOwner memory ownerInfo = jbOwner;\n\n        if (ownerInfo.projectId == 0) {\n            return ownerInfo.owner;\n        }\n\n        return PROJECTS.ownerOf(ownerInfo.projectId);\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Reverts if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        JBOwner memory ownerInfo = jbOwner;\n\n        _requirePermissionFrom({\n            account: ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId),\n            projectId: ownerInfo.projectId,\n            permissionId: ownerInfo.permissionId\n        });\n    }\n\n    //*********************************************************************//\n    // ---------------------- public transactions ------------------------ //\n    //*********************************************************************//\n\n    /// @notice Gives up ownership of this contract, making it impossible to call `onlyOwner`/`_checkOwner` functions.\n    /// Can only be called by the current owner.\n    function renounceOwnership() public virtual override {\n        _checkOwner();\n        _transferOwnership(address(0), 0);\n    }\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function setPermissionId(uint8 permissionId) public virtual override {\n        _checkOwner();\n        _setPermissionId(permissionId);\n    }\n\n    /// @notice Transfers ownership of this contract to a new account (the `newOwner`). Can only be called by the\n    /// current owner.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function transferOwnership(address newOwner) public virtual override {\n        _checkOwner();\n        if (newOwner == address(0)) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfer ownership of this contract to a new Juicebox project.\n    /// @dev The `projectId` must fit within a `uint88`.\n    /// @param projectId The ID of the project that should receive ownership of this contract.\n    function transferOwnershipToProject(uint256 projectId) public virtual override {\n        _checkOwner();\n        if (projectId == 0 || projectId > type(uint88).max) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n\n        _transferOwnership(address(0), uint88(projectId));\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Either `newOwner` or `newProjectId` is non-zero or both are zero. But they can never both be non-zero.\n    /// @dev This function exists because some contracts will try to deploy contracts for a project before\n    function _emitTransferEvent(address previousOwner, address newOwner, uint88 newProjectId) internal virtual;\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @dev Internal function without access restriction.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function _setPermissionId(uint8 permissionId) internal virtual {\n        jbOwner.permissionId = permissionId;\n        emit PermissionIdChanged({newId: permissionId, caller: msg.sender});\n    }\n\n    /// @notice Helper to allow for drop-in replacement of OpenZeppelin.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function _transferOwnership(address newOwner) internal virtual {\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfers this contract's ownership to an address (`newOwner`) OR a Juicebox project (`projectId`).\n    /// @dev Updates this contract's `JBOwner` owner information.\n    /// @dev If both `newOwner` and `projectId` are set, this will revert.\n    /// @dev Internal function without access restriction.\n    /// @param newOwner The address that should receive ownership of this contract.\n    /// @param projectId The ID of the project that this contract should respect the ownership of.\n    function _transferOwnership(address newOwner, uint88 projectId) internal virtual {\n        // Can't set both a new owner and a new project ID.\n        if (projectId != 0 && newOwner != address(0)) {\n            revert JBOwnableOverrides_InvalidNewOwner();\n        }\n        // Load the owner information from storage.\n        JBOwner memory ownerInfo = jbOwner;\n        // Get the address of the old owner.\n        address oldOwner = ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId);\n        // Update the stored owner information to the new owner and reset the `permissionId`.\n        // This is to prevent permissions clashes for the new user/owner.\n        jbOwner = JBOwner({owner: newOwner, projectId: projectId, permissionId: 0});\n        // Emit a transfer event with the new owner's address.\n        _emitTransferEvent(oldOwner, newOwner, projectId);\n    }\n}\n"
			},
			"node_modules/@bananapus/ownable/src/interfaces/IJBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\n\ninterface IJBOwnable {\n    event PermissionIdChanged(uint8 newId, address caller);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n    function jbOwner() external view returns (address owner, uint88 projectOwner, uint8 permissionId);\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n    function setPermissionId(uint8 permissionId) external;\n    function transferOwnership(address newOwner) external;\n    function transferOwnershipToProject(uint256 projectId) external;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/struct/JBOwner.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Owner information for a given instance of `JBOwnableOverrides`.\n/// @custom:member owner If `projectId` is 0 and this is set, this static address has owner access.\n/// @custom:member projectId Unless this is 0, this project's owner has owner access.\n/// @custom:member permissionId The ID of the permission required from the project's owner to have owner access. See\n/// `JBPermissions` in `juice-contracts-v4`.\nstruct JBOwner {\n    address owner;\n    uint88 projectId;\n    uint8 permissionId;\n}\n"
			},
			"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Permission IDs for `JBPermissions`, used throughout the Bananapus ecosystem. See\n/// [`JBPermissions`](https://github.com/Bananapus/nana-core/blob/main/src/JBPermissions.sol)\n/// @dev `JBPermissions` allows one address to grant another address permission to call functions in Juicebox contracts\n/// on their behalf. Each ID in `JBPermissionIds` grants access to a specific set of these functions.\nlibrary JBPermissionIds {\n    uint8 internal constant ROOT = 1; // All permissions across every contract. Very dangerous. BE CAREFUL!\n\n    /* Used by `nana-core`: https://github.com/Bananapus/nana-core */\n    uint8 internal constant QUEUE_RULESETS = 2; // Permission to call `JBController.queueRulesetsOf` and\n        // `JBController.launchRulesetsFor`.\n    uint8 internal constant CASH_OUT_TOKENS = 3; // Permission to call `JBMultiTerminal.cashOutTokensOf`.\n    uint8 internal constant SEND_PAYOUTS = 4; // Permission to call `JBMultiTerminal.sendPayoutsOf`.\n    uint8 internal constant MIGRATE_TERMINAL = 5; // Permission to call `JBMultiTerminal.migrateBalanceOf`.\n    uint8 internal constant SET_PROJECT_URI = 6; // Permission to call `JBController.setUriOf`.\n    uint8 internal constant DEPLOY_ERC20 = 7; // Permission to call `JBController.deployERC20For`.\n    uint8 internal constant SET_TOKEN = 8; // Permission to call `JBController.setTokenFor`.\n    uint8 internal constant MINT_TOKENS = 9; // Permission to call `JBController.mintTokensOf`.\n    uint8 internal constant BURN_TOKENS = 10; // Permission to call `JBController.burnTokensOf`.\n    uint8 internal constant CLAIM_TOKENS = 11; // Permission to call `JBController.claimTokensFor`.\n    uint8 internal constant TRANSFER_CREDITS = 12; // Permission to call `JBController.transferCreditsFrom`.\n    uint8 internal constant SET_CONTROLLER = 13; // Permission to call `JBDirectory.setControllerOf`.\n    uint8 internal constant SET_TERMINALS = 14; // Permission to call `JBDirectory.setTerminalsOf`.\n    // Be careful - `SET_TERMINALS` can be used to remove the primary terminal.\n    uint8 internal constant SET_PRIMARY_TERMINAL = 15; // Permission to call `JBDirectory.setPrimaryTerminalOf`.\n    uint8 internal constant USE_ALLOWANCE = 16; // Permission to call `JBMultiTerminal.useAllowanceOf`.\n    uint8 internal constant SET_SPLIT_GROUPS = 17; // Permission to call `JBController.setSplitGroupsOf`.\n    uint8 internal constant ADD_PRICE_FEED = 18; // Permission to call `JBPrices.addPriceFeedFor`.\n    uint8 internal constant ADD_ACCOUNTING_CONTEXTS = 19; // Permission to call\n        // `JBMultiTerminal.addAccountingContextsFor`.\n\n    /* Used by `nana-721-hook`: https://github.com/Bananapus/nana-721-hook */\n    uint8 internal constant ADJUST_721_TIERS = 20; // Permission to call `JB721TiersHook.adjustTiers`.\n    uint8 internal constant SET_721_METADATA = 21; // Permission to call `JB721TiersHook.setMetadata`.\n    uint8 internal constant MINT_721 = 22; // Permission to call `JB721TiersHook.mintFor`.\n    uint8 internal constant SET_721_DISCOUNT_PERCENT = 23; // Permission to call `JB721TiersHook.setDiscountPercentOf`.\n\n    /* Used by `nana-buyback-hook`: https://github.com/Bananapus/nana-buyback-hook */\n    uint8 internal constant SET_BUYBACK_TWAP = 24; // Permission to call `JBBuybackHook.setTwapWindowOf` and\n        // `JBBuybackHook.setTwapSlippageToleranceOf`.\n    uint8 internal constant SET_BUYBACK_POOL = 25; // Permission to call `JBBuybackHook.setPoolFor`.\n\n    /* Used by `nana-swap-terminal`: https://github.com/Bananapus/nana-swap-terminal */\n    uint8 internal constant ADD_SWAP_TERMINAL_POOL = 26; // Permission to call `JBSwapTerminal.addDefaultPool`.\n    uint8 internal constant ADD_SWAP_TERMINAL_TWAP_PARAMS = 27; // Permission to call\n        // `JBSwapTerminal.addTwapParamsFor`.\n\n    /* Used by `nana-suckers`: https://github.com/Bananapus/nana-suckers */\n    uint8 internal constant MAP_SUCKER_TOKEN = 28; // Permission to call `BPSucker.mapToken`.\n    uint8 internal constant DEPLOY_SUCKERS = 29; // Permission to call `BPSuckerRegistry.deploySuckersFor`.\n    uint8 internal constant SUCKER_SAFETY = 30; // Permission to call `BPSucker.enableEmergencyHatchFor` and\n        // `BPSucker.setDeprecation`.\n}\n"
			},
			"node_modules/@openzeppelin/contracts/interfaces/IERC2981.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     *\n     * NOTE: ERC-2981 allows setting the royalty to 100% of the price. In that case all the price would be sent to the\n     * royalty receiver and 0 tokens to the seller. Contracts dealing with royalty should consider empty transfers.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC-2771 support.\n *\n * WARNING: Avoid using this pattern in contracts that rely in a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC-2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[:calldataLength - contextSuffixLength];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Panic.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Strings.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
			},
			"src/JB721TiersHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\nimport {IJBRulesets} from \"@bananapus/core/src/interfaces/IJBRulesets.sol\";\nimport {JBMetadataResolver} from \"@bananapus/core/src/libraries/JBMetadataResolver.sol\";\nimport {JBRulesetMetadataResolver} from \"@bananapus/core/src/libraries/JBRulesetMetadataResolver.sol\";\nimport {JBAfterPayRecordedContext} from \"@bananapus/core/src/structs/JBAfterPayRecordedContext.sol\";\nimport {JBBeforeCashOutRecordedContext} from \"@bananapus/core/src/structs/JBBeforeCashOutRecordedContext.sol\";\nimport {JBRuleset} from \"@bananapus/core/src/structs/JBRuleset.sol\";\nimport {JBOwnable} from \"@bananapus/ownable/src/JBOwnable.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JB721Hook} from \"./abstract/JB721Hook.sol\";\nimport {IJB721TiersHook} from \"./interfaces/IJB721TiersHook.sol\";\nimport {IJB721TiersHookStore} from \"./interfaces/IJB721TiersHookStore.sol\";\nimport {IJB721TokenUriResolver} from \"./interfaces/IJB721TokenUriResolver.sol\";\nimport {JB721TiersRulesetMetadataResolver} from \"./libraries/JB721TiersRulesetMetadataResolver.sol\";\nimport {JBIpfsDecoder} from \"./libraries/JBIpfsDecoder.sol\";\nimport {JB721Tier} from \"./structs/JB721Tier.sol\";\nimport {JB721TierConfig} from \"./structs/JB721TierConfig.sol\";\nimport {JB721TiersSetDiscountPercentConfig} from \"./structs/JB721TiersSetDiscountPercentConfig.sol\";\nimport {JB721InitTiersConfig} from \"./structs/JB721InitTiersConfig.sol\";\nimport {JB721TiersHookFlags} from \"./structs/JB721TiersHookFlags.sol\";\nimport {JB721TiersMintReservesConfig} from \"./structs/JB721TiersMintReservesConfig.sol\";\n\n/// @title JB721TiersHook\n/// @notice A Juicebox project can use this hook to sell tiered ERC-721 NFTs with different prices and metadata. When\n/// the project is paid, the hook may mint NFTs to the payer, depending on the hook's setup, the amount paid, and\n/// information specified by the payer. The project's owner can enable NFT cash outs through this hook, allowing\n/// holders to burn their NFTs to reclaim funds from the project (in proportion to the NFT's price).\ncontract JB721TiersHook is JBOwnable, ERC2771Context, JB721Hook, IJB721TiersHook {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error JB721TiersHook_AlreadyInitialized(uint256 projectId);\n    error JB721TiersHook_NoProjectId();\n    error JB721TiersHook_Overspending(uint256 leftoverAmount);\n    error JB721TiersHook_MintReserveNftsPaused();\n    error JB721TiersHook_TierTransfersPaused();\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice The contract storing and managing project rulesets.\n    IJBRulesets public immutable override RULESETS;\n\n    /// @notice The contract that stores and manages data for this contract's NFTs.\n    IJB721TiersHookStore public immutable override STORE;\n\n    //*********************************************************************//\n    // ---------------------- public stored properties ------------------- //\n    //*********************************************************************//\n    /// @notice The base URI for the NFT `tokenUris`.\n    string public override baseURI;\n\n    /// @notice This contract's metadata URI.\n    string public override contractURI;\n\n    /// @notice If an address pays more than the price of the NFT they received, the extra amount is stored as credits\n    /// which can be cashed out to mint NFTs.\n    /// @custom:param addr The address to get the NFT credits balance of.\n    /// @return The amount of credits the address has.\n    mapping(address addr => uint256) public override payCreditsOf;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice The first owner of each token ID, stored on first transfer out.\n    /// @custom:param The token ID of the NFT to get the stored first owner of.\n    mapping(uint256 tokenId => address) internal _firstOwnerOf;\n\n    /// @notice Packed context for the pricing of this contract's tiers.\n    /// @dev Packed into a uint256:\n    /// - currency in bits 0-31 (32 bits),\n    /// - pricing decimals in bits 32-39 (8 bits), and\n    /// - prices contract in bits 40-199 (160 bits).\n    uint256 internal _packedPricingContext;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A directory of terminals and controllers for projects.\n    /// @param permissions A contract storing permissions.\n    /// @param rulesets A contract storing and managing project rulesets.\n    /// @param store The contract which stores the NFT's data.\n    /// @param trustedForwarder The trusted forwarder for the ERC2771Context.\n    constructor(\n        IJBDirectory directory,\n        IJBPermissions permissions,\n        IJBRulesets rulesets,\n        IJB721TiersHookStore store,\n        address trustedForwarder\n    )\n        JBOwnable(permissions, directory.PROJECTS(), msg.sender, uint88(0))\n        JB721Hook(directory)\n        ERC2771Context(trustedForwarder)\n    {\n        RULESETS = rulesets;\n        STORE = store;\n    }\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice The first owner of an NFT.\n    /// @dev This is generally the address which paid for the NFT.\n    /// @param tokenId The token ID of the NFT to get the first owner of.\n    /// @return The address of the NFT's first owner.\n    function firstOwnerOf(uint256 tokenId) external view override returns (address) {\n        // Get a reference to the first owner.\n        address storedFirstOwner = _firstOwnerOf[tokenId];\n\n        // If the stored first owner is set, return it.\n        if (storedFirstOwner != address(0)) return storedFirstOwner;\n\n        // Otherwise, the first owner must be the current owner.\n        return _ownerOf(tokenId);\n    }\n\n    /// @notice Context for the pricing of this hook's tiers.\n    /// @dev If the `prices` contract is the zero address, this contract only accepts payments in the `currency` token.\n    /// @return currency The currency used for tier prices.\n    /// @return decimals The amount of decimals being used in tier prices.\n    /// @return prices The prices contract used to resolve the value of payments in currencies other than `currency`.\n    function pricingContext() external view override returns (uint256 currency, uint256 decimals, IJBPrices prices) {\n        // Get a reference to the packed pricing context.\n        uint256 packed = _packedPricingContext;\n        // currency in bits 0-31 (32 bits).\n        currency = uint256(uint32(packed));\n        // pricing decimals in bits 32-39 (8 bits).\n        decimals = uint256(uint8(packed >> 32));\n        // prices contract in bits 40-199 (160 bits).\n        prices = IJBPrices(address(uint160(packed >> 40)));\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice The total number of this hook's NFTs that an address holds (from all tiers).\n    /// @param owner The address to check the balance of.\n    /// @return balance The number of NFTs the address owns across this hook's tiers.\n    function balanceOf(address owner) public view override returns (uint256 balance) {\n        return STORE.balanceOf(address(this), owner);\n    }\n\n    /// @notice Initializes a cloned copy of the original `JB721Hook` contract.\n    /// @param projectId The ID of the project this this hook is associated with.\n    /// @param name The name of the NFT collection.\n    /// @param symbol The symbol representing the NFT collection.\n    /// @param baseUri The URI to use as a base for full NFT `tokenUri`s.\n    /// @param tokenUriResolver An optional contract responsible for resolving the token URI for each NFT's token ID.\n    /// @param contractUri A URI where this contract's metadata can be found.\n    /// @param tiersConfig The NFT tiers and pricing context to initialize the hook with. The tiers must be sorted by\n    /// price (from least to greatest).\n    /// @param flags A set of additional options which dictate how the hook behaves.\n    function initialize(\n        uint256 projectId,\n        string memory name,\n        string memory symbol,\n        string memory baseUri,\n        IJB721TokenUriResolver tokenUriResolver,\n        string memory contractUri,\n        JB721InitTiersConfig memory tiersConfig,\n        JB721TiersHookFlags memory flags\n    )\n        public\n        override\n    {\n        // Stop re-initialization by ensuring a projectId is provided and doesn't already exist.\n        if (PROJECT_ID != 0) revert JB721TiersHook_AlreadyInitialized(PROJECT_ID);\n\n        // Make sure a projectId is provided.\n        if (projectId == 0) revert JB721TiersHook_NoProjectId();\n\n        // Initialize the superclass.\n        JB721Hook._initialize(projectId, name, symbol);\n\n        // Pack pricing context from the `tiersConfig`.\n        uint256 packed;\n        // pack the currency in bits 0-31 (32 bits).\n        packed |= uint256(tiersConfig.currency);\n        // pack the pricing decimals in bits 32-39 (8 bits).\n        packed |= uint256(tiersConfig.decimals) << 32;\n        // pack the prices contract in bits 40-199 (160 bits).\n        packed |= uint256(uint160(address(tiersConfig.prices))) << 40;\n        // Store the packed value.\n        // slither-disable-next-line events-maths\n        _packedPricingContext = packed;\n\n        // Store the base URI if provided.\n        if (bytes(baseUri).length != 0) baseURI = baseUri;\n\n        // Set the contract URI if provided.\n        if (bytes(contractUri).length != 0) contractURI = contractUri;\n\n        // Set the token URI resolver if provided.\n        if (tokenUriResolver != IJB721TokenUriResolver(address(0))) {\n            _recordSetTokenUriResolver(tokenUriResolver);\n        }\n\n        // Record the tiers in this hook's store.\n        // slither-disable-next-line unused-return\n        if (tiersConfig.tiers.length != 0) STORE.recordAddTiers(tiersConfig.tiers);\n\n        // Set the flags if needed.\n        if (\n            flags.noNewTiersWithReserves || flags.noNewTiersWithVotes || flags.noNewTiersWithOwnerMinting\n                || flags.preventOverspending\n        ) STORE.recordFlags(flags);\n\n        // Transfer ownership to the initializer.\n        _transferOwnership(_msgSender());\n    }\n\n    /// @notice The combined cash out weight of the NFTs with the specified token IDs.\n    /// @dev An NFT's cash out weight is its price.\n    /// @dev To get their relative cash out weight, divide the result by the `totalCashOutWeight(...)`.\n    /// @param tokenIds The token IDs of the NFTs to get the cumulative cash out weight of.\n    /// @return weight The cash out weight of the tokenIds.\n    function cashOutWeightOf(\n        uint256[] memory tokenIds,\n        JBBeforeCashOutRecordedContext calldata\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return STORE.cashOutWeightOf(address(this), tokenIds);\n    }\n\n    /// @notice Indicates if this contract adheres to the specified interface.\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param interfaceId The ID of the interface to check for adherence to.\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return interfaceId == type(IJB721TiersHook).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @notice The metadata URI of the NFT with the specified token ID.\n    /// @dev Defers to the `tokenUriResolver` if it is set. Otherwise, use the `tokenUri` corresponding with the NFT's\n    /// tier.\n    /// @param tokenId The token ID of the NFT to get the metadata URI of.\n    /// @return The token URI from the `tokenUriResolver` if it is set. If it isn't set, the token URI for the NFT's\n    /// tier.\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        // Get a reference to the `tokenUriResolver`.\n        IJB721TokenUriResolver resolver = STORE.tokenUriResolverOf(address(this));\n\n        // If a `tokenUriResolver` is set, use it to resolve the token URI.\n        if (address(resolver) != address(0)) return resolver.tokenUriOf(address(this), tokenId);\n\n        // Otherwise, return the token URI corresponding with the NFT's tier.\n        return JBIpfsDecoder.decode(baseURI, STORE.encodedTierIPFSUriOf(address(this), tokenId));\n    }\n\n    /// @notice The combined cash out weight of all outstanding NFTs.\n    /// @dev An NFT's cash out weight is its price.\n    /// @return weight The total cash out weight.\n    function totalCashOutWeight(JBBeforeCashOutRecordedContext calldata)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return STORE.totalCashOutWeight(address(this));\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Add or delete tiers.\n    /// @dev Only the contract's owner or an operator with the `ADJUST_TIERS` permission from the owner can adjust the\n    /// tiers.\n    /// @dev Any added tiers must adhere to this hook's `JB721TiersHookFlags`.\n    /// @param tiersToAdd The tiers to add, as an array of `JB721TierConfig` structs`.\n    /// @param tierIdsToRemove The tiers to remove, as an array of tier IDs.\n    function adjustTiers(JB721TierConfig[] calldata tiersToAdd, uint256[] calldata tierIdsToRemove) external override {\n        // Enforce permissions.\n        _requirePermissionFrom({account: owner(), projectId: PROJECT_ID, permissionId: JBPermissionIds.ADJUST_721_TIERS});\n\n        // Remove the tiers.\n        if (tierIdsToRemove.length != 0) {\n            // Emit events for each removed tier.\n            for (uint256 i; i < tierIdsToRemove.length; i++) {\n                emit RemoveTier({tierId: tierIdsToRemove[i], caller: _msgSender()});\n            }\n\n            // Record the removed tiers.\n            // slither-disable-next-line reentrancy-events\n            STORE.recordRemoveTierIds(tierIdsToRemove);\n        }\n\n        // Add the tiers.\n        if (tiersToAdd.length != 0) {\n            // Record the added tiers in the store.\n            uint256[] memory tierIdsAdded = STORE.recordAddTiers(tiersToAdd);\n\n            // Emit events for each added tier.\n            for (uint256 i; i < tiersToAdd.length; i++) {\n                emit AddTier({tierId: tierIdsAdded[i], tier: tiersToAdd[i], caller: _msgSender()});\n            }\n        }\n    }\n\n    /// @notice Manually mint NFTs from the provided tiers .\n    /// @param tierIds The IDs of the tiers to mint from.\n    /// @param beneficiary The address to mint to.\n    /// @return tokenIds The IDs of the newly minted tokens.\n    function mintFor(\n        uint16[] calldata tierIds,\n        address beneficiary\n    )\n        external\n        override\n        returns (uint256[] memory tokenIds)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({account: owner(), projectId: PROJECT_ID, permissionId: JBPermissionIds.MINT_721});\n\n        // Record the mint. The token IDs returned correspond to the tiers passed in.\n        // slither-disable-next-line reentrancy-events,unused-return\n        (tokenIds,) = STORE.recordMint({\n            amount: type(uint256).max, // force the mint.\n            tierIds: tierIds,\n            isOwnerMint: true // manual mint.\n        });\n\n        for (uint256 i; i < tierIds.length; i++) {\n            // Set the token ID.\n            uint256 tokenId = tokenIds[i];\n\n            // Mint the NFT.\n            _mint(beneficiary, tokenId);\n\n            emit Mint({\n                tokenId: tokenId,\n                tierId: tierIds[i],\n                beneficiary: beneficiary,\n                totalAmountPaid: 0,\n                caller: _msgSender()\n            });\n        }\n    }\n\n    /// @notice Mint pending reserved NFTs based on the provided information.\n    /// @dev \"Pending\" means that the NFTs have been reserved, but have not been minted yet.\n    /// @param reserveMintConfigs Contains information about how many reserved tokens to mint for each tier.\n    function mintPendingReservesFor(JB721TiersMintReservesConfig[] calldata reserveMintConfigs) external override {\n        for (uint256 i; i < reserveMintConfigs.length; i++) {\n            // Get a reference to the params being iterated upon.\n            JB721TiersMintReservesConfig memory params = reserveMintConfigs[i];\n\n            // Mint pending reserved NFTs from the tier.\n            mintPendingReservesFor(params.tierId, params.count);\n        }\n    }\n\n    /// @notice Allows the collection's owner to set the discount for a tier, if the tier allows it.\n    /// @dev Only the contract's owner or an operator with the `SET_721_DISCOUNT_PERCENT` permission from the owner can\n    /// adjust the\n    /// tiers.\n    /// @param tierId The ID of the tier to set the discount of.\n    /// @param discountPercent The discount percent to set.\n    function setDiscountPercentOf(uint256 tierId, uint256 discountPercent) external override {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: owner(),\n            projectId: PROJECT_ID,\n            permissionId: JBPermissionIds.SET_721_DISCOUNT_PERCENT\n        });\n        _setDiscountPercentOf(tierId, discountPercent);\n    }\n\n    /// @notice Allows the collection's owner to set the discount percent for multiple tiers.\n    /// @param configs The configs to set the discount percent for.\n    function setDiscountPercentsOf(JB721TiersSetDiscountPercentConfig[] calldata configs) external override {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: owner(),\n            projectId: PROJECT_ID,\n            permissionId: JBPermissionIds.SET_721_DISCOUNT_PERCENT\n        });\n\n        for (uint256 i; i < configs.length; i++) {\n            // Set the config being iterated on.\n            JB721TiersSetDiscountPercentConfig memory config = configs[i];\n\n            _setDiscountPercentOf(config.tierId, config.discountPercent);\n        }\n    }\n\n    /// @notice Update this hook's URI metadata properties.\n    /// @dev Only this contract's owner can set the metadata.\n    /// @param baseUri The new base URI.\n    /// @param contractUri The new contract URI.\n    /// @param tokenUriResolver The new URI resolver.\n    /// @param encodedIPFSTUriTierId The ID of the tier to set the encoded IPFS URI of.\n    /// @param encodedIPFSUri The encoded IPFS URI to set.\n    function setMetadata(\n        string calldata baseUri,\n        string calldata contractUri,\n        IJB721TokenUriResolver tokenUriResolver,\n        uint256 encodedIPFSTUriTierId,\n        bytes32 encodedIPFSUri\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({account: owner(), projectId: PROJECT_ID, permissionId: JBPermissionIds.SET_721_METADATA});\n\n        if (bytes(baseUri).length != 0) {\n            // Store the new base URI.\n            baseURI = baseUri;\n            emit SetBaseUri({baseUri: baseUri, caller: _msgSender()});\n        }\n        if (bytes(contractUri).length != 0) {\n            // Store the new contract URI.\n            contractURI = contractUri;\n            emit SetContractUri({uri: contractUri, caller: _msgSender()});\n        }\n\n        if (tokenUriResolver != IJB721TokenUriResolver(address(this))) {\n            // Store the new URI resolver.\n            // slither-disable-next-line reentrancy-events\n            _recordSetTokenUriResolver(tokenUriResolver);\n        }\n        if (encodedIPFSTUriTierId != 0 && encodedIPFSUri != bytes32(0)) {\n            emit SetEncodedIPFSUri({tierId: encodedIPFSTUriTierId, encodedUri: encodedIPFSUri, caller: _msgSender()});\n\n            // Store the new encoded IPFS URI.\n            STORE.recordSetEncodedIPFSUriOf(encodedIPFSTUriTierId, encodedIPFSUri);\n        }\n    }\n\n    //*********************************************************************//\n    // ----------------------- public transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Mint reserved pending reserved NFTs within the provided tier.\n    /// @dev \"Pending\" means that the NFTs have been reserved, but have not been minted yet.\n    /// @param tierId The ID of the tier to mint reserved NFTs from.\n    /// @param count The number of reserved NFTs to mint.\n    function mintPendingReservesFor(uint256 tierId, uint256 count) public override {\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = _currentRulesetOf(PROJECT_ID);\n\n        // Pending reserve mints must not be paused.\n        if (JB721TiersRulesetMetadataResolver.mintPendingReservesPaused((JBRulesetMetadataResolver.metadata(ruleset))))\n        {\n            revert JB721TiersHook_MintReserveNftsPaused();\n        }\n\n        // Record the reserved mint for the tier.\n        // slither-disable-next-line reentrancy-events,calls-loop\n        uint256[] memory tokenIds = STORE.recordMintReservesFor(tierId, count);\n\n        // Keep a reference to the beneficiary.\n        // slither-disable-next-line calls-loop\n        address reserveBeneficiary = STORE.reserveBeneficiaryOf(address(this), tierId);\n\n        for (uint256 i; i < count; i++) {\n            // Set the token ID.\n            uint256 tokenId = tokenIds[i];\n\n            emit MintReservedNft({\n                tokenId: tokenId,\n                tierId: tierId,\n                beneficiary: reserveBeneficiary,\n                caller: _msgSender()\n            });\n\n            // Mint the NFT.\n            // slither-disable-next-line reentrency-events\n            _mint(reserveBeneficiary, tokenId);\n        }\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @dev ERC-2771 specifies the context as being a single address (20 bytes).\n    function _contextSuffixLength() internal view virtual override(ERC2771Context, Context) returns (uint256) {\n        return super._contextSuffixLength();\n    }\n\n    /// @notice The project's current ruleset.\n    /// @param projectId The ID of the project to check.\n    /// @return The project's current ruleset.\n    function _currentRulesetOf(uint256 projectId) internal view returns (JBRuleset memory) {\n        // slither-disable-next-line calls-loop\n        return RULESETS.currentOf(projectId);\n    }\n\n    /// @notice A function which gets called after NFTs have been cashed out and recorded by the terminal.\n    /// @param tokenIds The token IDs of the NFTs that were burned.\n    function _didBurn(uint256[] memory tokenIds) internal virtual override {\n        // Add to burned counter.\n        STORE.recordBurn(tokenIds);\n    }\n\n    /// @notice Mints one NFT from each of the specified tiers for the beneficiary.\n    /// @dev The same tier can be specified more than once.\n    /// @param amount The amount to base the mints on. The total price of the NFTs being minted cannot be larger than\n    /// this amount.\n    /// @param mintTierIds An array of NFT tier IDs to be minted.\n    /// @param beneficiary The address receiving the newly minted NFTs.\n    /// @return leftoverAmount The `amount` leftover after minting.\n    function _mintAll(\n        uint256 amount,\n        uint16[] memory mintTierIds,\n        address beneficiary\n    )\n        internal\n        returns (uint256 leftoverAmount)\n    {\n        // Keep a reference to the NFT token IDs.\n        uint256[] memory tokenIds;\n\n        // Record the NFT mints. The token IDs returned correspond to the tier IDs passed in.\n        (tokenIds, leftoverAmount) = STORE.recordMint({\n            amount: amount,\n            tierIds: mintTierIds,\n            isOwnerMint: false // Not a manual mint\n        });\n\n        // Loop through each token ID and mint the corresponding NFT.\n        for (uint256 i; i < tokenIds.length; i++) {\n            // Get a reference to the token ID being iterated on.\n            uint256 tokenId = tokenIds[i];\n\n            emit Mint({\n                tokenId: tokenId,\n                tierId: mintTierIds[i],\n                beneficiary: beneficiary,\n                totalAmountPaid: amount,\n                caller: _msgSender()\n            });\n\n            // Mint the NFT.\n            // slither-disable-next-line reentrancy-events\n            _mint(beneficiary, tokenId);\n        }\n    }\n\n    /// @notice Returns the calldata, prefered to use over `msg.data`\n    /// @return calldata the `msg.data` of this call\n    function _msgData() internal view override(ERC2771Context, Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    /// @notice Returns the sender, prefered to use over `msg.sender`\n    /// @return sender the sender address of this call.\n    function _msgSender() internal view override(ERC2771Context, Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    /// @notice Process a payment, minting NFTs and updating credits as necessary.\n    /// @param context Payment context provided by the terminal after it has recorded the payment in the terminal store.\n    function _processPayment(JBAfterPayRecordedContext calldata context) internal virtual override {\n        // Normalize the payment value based on the pricing context.\n        uint256 value;\n\n        {\n            uint256 packed = _packedPricingContext;\n            // pricing currency in bits 0-31 (32 bits).\n            uint256 pricingCurrency = uint256(uint32(packed));\n            if (context.amount.currency == pricingCurrency) {\n                value = context.amount.value;\n            } else {\n                // prices in bits 40-199 (160 bits).\n                IJBPrices prices = IJBPrices(address(uint160(packed >> 40)));\n                if (prices != IJBPrices(address(0))) {\n                    // pricing decimals in bits 32-39 (8 bits).\n                    uint256 pricingDecimals = uint256(uint8(packed >> 32));\n                    value = mulDiv(\n                        context.amount.value,\n                        10 ** pricingDecimals,\n                        prices.pricePerUnitOf({\n                            projectId: PROJECT_ID,\n                            pricingCurrency: context.amount.currency,\n                            unitCurrency: pricingCurrency,\n                            decimals: context.amount.decimals\n                        })\n                    );\n                } else {\n                    return;\n                }\n            }\n        }\n\n        // Keep a reference to the number of NFT credits the beneficiary already has.\n        uint256 payCredits = payCreditsOf[context.beneficiary];\n\n        // Set the leftover amount as the initial value.\n        uint256 leftoverAmount = value;\n\n        // If the payer is the beneficiary, combine their NFT credits with the amount paid.\n        uint256 unusedPayCredits;\n        if (context.payer == context.beneficiary) {\n            unchecked {\n                leftoverAmount += payCredits;\n            }\n        } else {\n            // Otherwise, the payer's NFT credits won't be used, and we keep track of the unused credits.\n            unusedPayCredits = payCredits;\n        }\n\n        // Keep a reference to the boolean indicating whether paying more than the price of the NFTs being minted is\n        // allowed. Defaults to the collection's flag.\n        bool allowOverspending = !STORE.flagsOf(address(this)).preventOverspending;\n\n        // Resolve the metadata.\n        (bool found, bytes memory metadata) =\n            JBMetadataResolver.getDataFor(JBMetadataResolver.getId(\"pay\", METADATA_ID_TARGET), context.payerMetadata);\n\n        if (found) {\n            // Keep a reference to the IDs of the tier be to minted.\n            uint16[] memory tierIdsToMint;\n\n            // Keep a reference to the payer's flag indicating whether overspending is allowed.\n            bool payerAllowsOverspending;\n\n            // Decode the metadata.\n            (payerAllowsOverspending, tierIdsToMint) = abi.decode(metadata, (bool, uint16[]));\n\n            // Make sure overspending is allowed if requested.\n            if (allowOverspending && !payerAllowsOverspending) {\n                allowOverspending = false;\n            }\n\n            // Mint NFTs from the tiers as specified.\n            if (tierIdsToMint.length != 0) {\n                // slither-disable-next-line reentrancy-events,reentrancy-no-eth\n                leftoverAmount =\n                    _mintAll({amount: leftoverAmount, mintTierIds: tierIdsToMint, beneficiary: context.beneficiary});\n            }\n        }\n\n        // If overspending is allowed and there are leftover funds, add those funds to the beneficiary's NFT credits.\n        if (leftoverAmount != 0) {\n            // If overspending isn't allowed, revert.\n            if (!allowOverspending) revert JB721TiersHook_Overspending(leftoverAmount);\n\n            // Increment the leftover amount.\n            unchecked {\n                // Keep a reference to the amount of new NFT credits.\n                uint256 newPayCredits = leftoverAmount + unusedPayCredits;\n\n                // Emit the change in NFT credits.\n                if (newPayCredits > payCredits) {\n                    emit AddPayCredits({\n                        amount: newPayCredits - payCredits,\n                        newTotalCredits: newPayCredits,\n                        account: context.beneficiary,\n                        caller: _msgSender()\n                    });\n                } else if (payCredits > newPayCredits) {\n                    emit UsePayCredits({\n                        amount: payCredits - newPayCredits,\n                        newTotalCredits: newPayCredits,\n                        account: context.beneficiary,\n                        caller: _msgSender()\n                    });\n                }\n\n                // Store the new NFT credits for the beneficiary.\n                payCreditsOf[context.beneficiary] = newPayCredits;\n            }\n            // Otherwise, reset their NFT credits.\n        } else if (payCredits != unusedPayCredits) {\n            // Emit the change in NFT credits.\n            emit UsePayCredits({\n                amount: payCredits - unusedPayCredits,\n                newTotalCredits: unusedPayCredits,\n                account: context.beneficiary,\n                caller: _msgSender()\n            });\n\n            // Store the new NFT credits.\n            payCreditsOf[context.beneficiary] = unusedPayCredits;\n        }\n    }\n\n    /// @notice Record the setting of a new token URI resolver.\n    /// @param tokenUriResolver The new token URI resolver.\n    function _recordSetTokenUriResolver(IJB721TokenUriResolver tokenUriResolver) internal {\n        emit SetTokenUriResolver({resolver: tokenUriResolver, caller: _msgSender()});\n\n        STORE.recordSetTokenUriResolver(tokenUriResolver);\n    }\n\n    /// @notice Internal function to set the discount percent for a tier.\n    /// @param tierId The ID of the tier to set the discount percent for.\n    /// @param discountPercent The discount percent to set for the tier.\n    function _setDiscountPercentOf(uint256 tierId, uint256 discountPercent) internal {\n        emit SetDiscountPercent({tierId: tierId, discountPercent: discountPercent, caller: _msgSender()});\n\n        // Record the discount percent for the tier.\n        // slither-disable-next-line calls-loop\n        STORE.recordSetDiscountPercentOf({tierId: tierId, discountPercent: discountPercent});\n    }\n\n    /// @notice Before transferring an NFT, register its first owner (if necessary).\n    /// @param to The address the NFT is being transferred to.\n    /// @param tokenId The token ID of the NFT being transferred.\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address from) {\n        // Get a reference to the tier.\n        // slither-disable-next-line calls-loop\n        JB721Tier memory tier = STORE.tierOfTokenId({hook: address(this), tokenId: tokenId, includeResolvedUri: false});\n\n        // Record the transfers and keep a reference to where the token is coming from.\n        from = super._update(to, tokenId, auth);\n\n        // Transfers must not be paused (when not minting or burning).\n        if (from != address(0)) {\n            // If transfers are pausable, check if they're paused.\n            if (tier.transfersPausable) {\n                // Get a reference to the project's current ruleset.\n                JBRuleset memory ruleset = _currentRulesetOf(PROJECT_ID);\n\n                // If transfers are paused and the NFT isn't being transferred to the zero address, revert.\n                if (\n                    to != address(0)\n                        && JB721TiersRulesetMetadataResolver.transfersPaused((JBRulesetMetadataResolver.metadata(ruleset)))\n                ) revert JB721TiersHook_TierTransfersPaused();\n            }\n\n            // If the token isn't already associated with a first owner, store the sender as the first owner.\n            // slither-disable-next-line calls-loop\n            if (_firstOwnerOf[tokenId] == address(0)) _firstOwnerOf[tokenId] = from;\n        }\n\n        // Record the transfer.\n        // slither-disable-next-line reentrency-events,calls-loop\n        STORE.recordTransferForTier(tier.id, from, to);\n    }\n}\n"
			},
			"src/abstract/ERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity 0.8.23;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC721Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) internal _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function _initialize(string memory name_, string memory symbol_) internal {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return spender != address(0)\n            && (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     * a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     * a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data`\n     * parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
			},
			"src/abstract/JB721Hook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IJBCashOutHook} from \"@bananapus/core/src/interfaces/IJBCashOutHook.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBPayHook} from \"@bananapus/core/src/interfaces/IJBPayHook.sol\";\nimport {IJBRulesetDataHook} from \"@bananapus/core/src/interfaces/IJBRulesetDataHook.sol\";\nimport {IJBTerminal} from \"@bananapus/core/src/interfaces/IJBTerminal.sol\";\nimport {JBConstants} from \"@bananapus/core/src/libraries/JBConstants.sol\";\nimport {JBMetadataResolver} from \"@bananapus/core/src/libraries/JBMetadataResolver.sol\";\nimport {JBAfterPayRecordedContext} from \"@bananapus/core/src/structs/JBAfterPayRecordedContext.sol\";\nimport {JBAfterCashOutRecordedContext} from \"@bananapus/core/src/structs/JBAfterCashOutRecordedContext.sol\";\nimport {JBBeforePayRecordedContext} from \"@bananapus/core/src/structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeCashOutRecordedContext} from \"@bananapus/core/src/structs/JBBeforeCashOutRecordedContext.sol\";\nimport {JBCashOutHookSpecification} from \"@bananapus/core/src/structs/JBCashOutHookSpecification.sol\";\nimport {JBPayHookSpecification} from \"@bananapus/core/src/structs/JBPayHookSpecification.sol\";\nimport {IERC2981} from \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {ERC721} from \"./ERC721.sol\";\nimport {IJB721Hook} from \"../interfaces/IJB721Hook.sol\";\n\n/// @title JB721Hook\n/// @notice When a project which uses this hook is paid, this hook may mint NFTs to the payer, depending on this hook's\n/// setup, the amount paid, and information specified by the payer. The project's owner can enable NFT cash outs.\n/// through this hook, allowing the NFT holders to burn their NFTs to reclaim funds from the project (in proportion to\n/// the NFT's price).\nabstract contract JB721Hook is ERC721, IJB721Hook, IJBRulesetDataHook, IJBPayHook, IJBCashOutHook {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error JB721Hook_InvalidPay();\n    error JB721Hook_InvalidCashOut();\n    error JB721Hook_UnauthorizedToken(uint256 tokenId, address holder);\n    error JB721Hook_UnexpectedTokenCashedOut();\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice The ID used when parsing metadata.\n    address public immutable override METADATA_ID_TARGET;\n\n    //*********************************************************************//\n    // -------------------- public stored properties --------------------- //\n    //*********************************************************************//\n\n    /// @notice The ID of the project that this contract is associated with.\n    uint256 public override PROJECT_ID;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A directory of terminals and controllers for projects.\n    constructor(IJBDirectory directory) {\n        DIRECTORY = directory;\n        // Store the address of the original hook deploy. Clones will each use the address of the instance they're based\n        // on.\n        METADATA_ID_TARGET = address(this);\n    }\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice The data calculated before a payment is recorded in the terminal store. This data is provided to the\n    /// terminal's `pay(...)` transaction.\n    /// @dev Sets this contract as the pay hook. Part of `IJBRulesetDataHook`.\n    /// @param context The payment context passed to this contract by the `pay(...)` function.\n    /// @return weight The new `weight` to use, overriding the ruleset's `weight`.\n    /// @return hookSpecifications The amount and data to send to pay hooks (this contract) instead of adding to the\n    /// terminal's balance.\n    function beforePayRecordedWith(JBBeforePayRecordedContext calldata context)\n        public\n        view\n        virtual\n        override\n        returns (uint256 weight, JBPayHookSpecification[] memory hookSpecifications)\n    {\n        // Forward the received weight and memo, and use this contract as the only pay hook.\n        weight = context.weight;\n        hookSpecifications = new JBPayHookSpecification[](1);\n        hookSpecifications[0] = JBPayHookSpecification({hook: this, amount: 0, metadata: bytes(\"\")});\n    }\n\n    /// @notice The data calculated before a cash out is recorded in the terminal store. This data is provided to the\n    /// terminal's `cashOutTokensOf(...)` transaction.\n    /// @dev Sets this contract as the cash out hook. Part of `IJBRulesetDataHook`.\n    /// @dev This function is used for NFT cash outs, and will only be called if the project's ruleset has\n    /// `useDataHookForCashOut` set to `true`.\n    /// @param context The cash out context passed to this contract by the `cashOutTokensOf(...)` function.\n    /// @return cashOutTaxRate The cash out tax rate influencing the reclaim amount.\n    /// @return cashOutCount The amount of tokens that should be considered cashed out.\n    /// @return totalSupply The total amount of tokens that are considered to be existing.\n    /// @return hookSpecifications The amount and data to send to cash out hooks (this contract) instead of returning to\n    /// the beneficiary.\n    function beforeCashOutRecordedWith(JBBeforeCashOutRecordedContext calldata context)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint256 cashOutTaxRate,\n            uint256 cashOutCount,\n            uint256 totalSupply,\n            JBCashOutHookSpecification[] memory hookSpecifications\n        )\n    {\n        // Make sure (fungible) project tokens aren't also being cashed out.\n        if (context.cashOutCount > 0) revert JB721Hook_UnexpectedTokenCashedOut();\n\n        // Fetch the cash out hook metadata using the corresponding metadata ID.\n        (bool metadataExists, bytes memory metadata) =\n            JBMetadataResolver.getDataFor(JBMetadataResolver.getId(\"cashOut\", METADATA_ID_TARGET), context.metadata);\n\n        // Use this contract as the only cash out hook.\n        hookSpecifications = new JBCashOutHookSpecification[](1);\n        hookSpecifications[0] = JBCashOutHookSpecification(this, 0, bytes(\"\"));\n\n        uint256[] memory decodedTokenIds;\n\n        // Decode the metadata.\n        if (metadataExists) decodedTokenIds = abi.decode(metadata, (uint256[]));\n\n        // Use the cash out weight of the provided 721s.\n        cashOutCount = cashOutWeightOf(decodedTokenIds, context);\n\n        // Use the total cash out weight of the 721s.\n        totalSupply = totalCashOutWeight(context);\n\n        // Use the cash out tax rate from the context.\n        cashOutTaxRate = context.cashOutTaxRate;\n    }\n\n    /// @notice Required by the IJBRulesetDataHook interfaces. Return false to not leak any permissions.\n    function hasMintPermissionFor(uint256, address) external pure returns (bool) {\n        return false;\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns the cumulative cash out weight of the specified token IDs relative to the\n    /// `totalCashOutWeight`.\n    /// @param tokenIds The NFT token IDs to calculate the cumulative cash out weight of.\n    /// @param context The cash out context passed to this contract by the `cashOutTokensOf(...)` function.\n    /// @return The cumulative cash out weight of the specified token IDs.\n    function cashOutWeightOf(\n        uint256[] memory tokenIds,\n        JBBeforeCashOutRecordedContext calldata context\n    )\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        tokenIds; // Prevents unused var compiler and natspec complaints.\n        context; // Prevents unused var compiler and natspec complaints.\n        return 0;\n    }\n\n    /// @notice Indicates if this contract adheres to the specified interface.\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param _interfaceId The ID of the interface to check for adherence to.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\n        return _interfaceId == type(IJB721Hook).interfaceId || _interfaceId == type(IJBRulesetDataHook).interfaceId\n            || _interfaceId == type(IJBPayHook).interfaceId || _interfaceId == type(IJBCashOutHook).interfaceId\n            || _interfaceId == type(IERC2981).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Calculates the cumulative cash out weight of all NFT token IDs.\n    /// @param context The cash out context passed to this contract by the `cashOutTokensOf(...)` function.\n    /// @return The total cumulative cash out weight of all NFT token IDs.\n    function totalCashOutWeight(JBBeforeCashOutRecordedContext calldata context)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        context; // Prevents unused var compiler and natspec complaints.\n        return 0;\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Initializes the contract by associating it with a project and adding ERC721 details.\n    /// @param projectId The ID of the project that this contract is associated with.\n    /// @param name The name of the NFT collection.\n    /// @param symbol The symbol representing the NFT collection.\n    function _initialize(uint256 projectId, string memory name, string memory symbol) internal {\n        ERC721._initialize(name, symbol);\n        PROJECT_ID = projectId;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Mints one or more NFTs to the `context.benficiary` upon payment if conditions are met. Part of\n    /// `IJBPayHook`.\n    /// @dev Reverts if the calling contract is not one of the project's terminals.\n    /// @param context The payment context passed in by the terminal.\n    // slither-disable-next-line locked-ether\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable virtual override {\n        uint256 projectId = PROJECT_ID;\n\n        // Make sure the caller is a terminal of the project, and that the call is being made on behalf of an\n        // interaction with the correct project.\n        if (\n            msg.value != 0 || !DIRECTORY.isTerminalOf(projectId, IJBTerminal(msg.sender))\n                || context.projectId != projectId\n        ) revert JB721Hook_InvalidPay();\n\n        // Process the payment.\n        _processPayment(context);\n    }\n\n    /// @notice Burns the specified NFTs upon token holder cash out, reclaiming funds from the project's balance for\n    /// `context.beneficiary`. Part of `IJBCashOutHook`.\n    /// @dev Reverts if the calling contract is not one of the project's terminals.\n    /// @param context The cash out context passed in by the terminal.\n    // slither-disable-next-line locked-ether\n    function afterCashOutRecordedWith(JBAfterCashOutRecordedContext calldata context)\n        external\n        payable\n        virtual\n        override\n    {\n        // Keep a reference to the project ID.\n        uint256 projectId = PROJECT_ID;\n\n        // Make sure the caller is a terminal of the project, and that the call is being made on behalf of an\n        // interaction with the correct project.\n        if (\n            msg.value != 0 || !DIRECTORY.isTerminalOf(projectId, IJBTerminal(msg.sender))\n                || context.projectId != projectId\n        ) revert JB721Hook_InvalidCashOut();\n\n        // Fetch the cash out hook metadata using the corresponding metadata ID.\n        (bool metadataExists, bytes memory metadata) = JBMetadataResolver.getDataFor(\n            JBMetadataResolver.getId(\"cashOut\", METADATA_ID_TARGET), context.cashOutMetadata\n        );\n\n        uint256[] memory decodedTokenIds;\n\n        // Decode the metadata.\n        if (metadataExists) decodedTokenIds = abi.decode(metadata, (uint256[]));\n\n        // Iterate through the NFTs, burning them if the owner is correct.\n        for (uint256 i; i < decodedTokenIds.length; i++) {\n            // Set the current NFT's token ID.\n            uint256 tokenId = decodedTokenIds[i];\n\n            // Make sure the token's owner is correct.\n            if (_ownerOf(tokenId) != context.holder) revert JB721Hook_UnauthorizedToken(tokenId, context.holder);\n\n            // Burn the token.\n            _burn(tokenId);\n        }\n\n        // Call the hook.\n        _didBurn(decodedTokenIds);\n    }\n\n    //*********************************************************************//\n    // ---------------------- internal transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Executes after NFTs have been burned via cash out.\n    /// @param tokenIds The token IDs of the NFTs that were burned.\n    function _didBurn(uint256[] memory tokenIds) internal virtual;\n\n    /// @notice Process a received payment.\n    /// @param context The payment context passed in by the terminal.\n    function _processPayment(JBAfterPayRecordedContext calldata context) internal virtual;\n}\n"
			},
			"src/interfaces/IJB721Hook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\n\ninterface IJB721Hook {\n    function DIRECTORY() external view returns (IJBDirectory);\n    function METADATA_ID_TARGET() external view returns (address);\n    function PROJECT_ID() external view returns (uint256);\n}\n"
			},
			"src/interfaces/IJB721TiersHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\nimport {IJBRulesets} from \"@bananapus/core/src/interfaces/IJBRulesets.sol\";\n\nimport {IJB721Hook} from \"./IJB721Hook.sol\";\nimport {IJB721TiersHookStore} from \"./IJB721TiersHookStore.sol\";\nimport {IJB721TokenUriResolver} from \"./IJB721TokenUriResolver.sol\";\nimport {JB721InitTiersConfig} from \"../structs/JB721InitTiersConfig.sol\";\nimport {JB721TierConfig} from \"../structs/JB721TierConfig.sol\";\nimport {JB721TiersHookFlags} from \"../structs/JB721TiersHookFlags.sol\";\nimport {JB721TiersMintReservesConfig} from \"../structs/JB721TiersMintReservesConfig.sol\";\nimport {JB721TiersSetDiscountPercentConfig} from \"../structs/JB721TiersSetDiscountPercentConfig.sol\";\n\ninterface IJB721TiersHook is IJB721Hook {\n    event AddPayCredits(\n        uint256 indexed amount, uint256 indexed newTotalCredits, address indexed account, address caller\n    );\n    event AddTier(uint256 indexed tierId, JB721TierConfig tier, address caller);\n    event Mint(\n        uint256 indexed tokenId,\n        uint256 indexed tierId,\n        address indexed beneficiary,\n        uint256 totalAmountPaid,\n        address caller\n    );\n    event MintReservedNft(uint256 indexed tokenId, uint256 indexed tierId, address indexed beneficiary, address caller);\n    event RemoveTier(uint256 indexed tierId, address caller);\n    event SetBaseUri(string indexed baseUri, address caller);\n    event SetContractUri(string indexed uri, address caller);\n    event SetDiscountPercent(uint256 indexed tierId, uint256 discountPercent, address caller);\n    event SetEncodedIPFSUri(uint256 indexed tierId, bytes32 encodedUri, address caller);\n    event SetTokenUriResolver(IJB721TokenUriResolver indexed resolver, address caller);\n    event UsePayCredits(\n        uint256 indexed amount, uint256 indexed newTotalCredits, address indexed account, address caller\n    );\n\n    function RULESETS() external view returns (IJBRulesets);\n    function STORE() external view returns (IJB721TiersHookStore);\n\n    function baseURI() external view returns (string memory);\n    function contractURI() external view returns (string memory);\n    function firstOwnerOf(uint256 tokenId) external view returns (address);\n    function payCreditsOf(address addr) external view returns (uint256);\n    function pricingContext() external view returns (uint256, uint256, IJBPrices);\n\n    function adjustTiers(JB721TierConfig[] calldata tierDataToAdd, uint256[] calldata tierIdsToRemove) external;\n    function initialize(\n        uint256 projectId,\n        string memory name,\n        string memory symbol,\n        string memory baseUri,\n        IJB721TokenUriResolver tokenUriResolver,\n        string memory contractUri,\n        JB721InitTiersConfig memory tiersConfig,\n        JB721TiersHookFlags memory flags\n    )\n        external;\n    function setDiscountPercentOf(uint256 tierId, uint256 discountPercent) external;\n    function setDiscountPercentsOf(JB721TiersSetDiscountPercentConfig[] calldata configs) external;\n    function mintFor(uint16[] calldata tierIds, address beneficiary) external returns (uint256[] memory tokenIds);\n    function mintPendingReservesFor(JB721TiersMintReservesConfig[] calldata reserveMintConfigs) external;\n    function mintPendingReservesFor(uint256 tierId, uint256 count) external;\n    function setMetadata(\n        string calldata baseUri,\n        string calldata contractMetadataUri,\n        IJB721TokenUriResolver tokenUriResolver,\n        uint256 encodedIPFSUriTierId,\n        bytes32 encodedIPFSUri\n    )\n        external;\n}\n"
			},
			"src/libraries/JB721TiersRulesetMetadataResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {JB721TiersRulesetMetadata} from \"../structs/JB721TiersRulesetMetadata.sol\";\n\n/// @title JB721TiersRulesetMetadataResolver\n/// @notice Utility library to parse and store ruleset metadata associated for the tiered 721 hook.\n/// @dev This library parses the `metadata` member of the `JBRulesetMetadata` struct.\nlibrary JB721TiersRulesetMetadataResolver {\n    function transfersPaused(uint256 data) internal pure returns (bool) {\n        return (data & 1) == 1;\n    }\n\n    function mintPendingReservesPaused(uint256 data) internal pure returns (bool) {\n        return ((data >> 1) & 1) == 1;\n    }\n\n    /// @notice Pack the ruleset metadata for the 721 hook into a single `uint256`.\n    /// @param metadata The metadata to validate and pack.\n    /// @return packed A `uint256` containing the packed metadata for the 721 hook.\n    function pack721TiersRulesetMetadata(JB721TiersRulesetMetadata memory metadata)\n        internal\n        pure\n        returns (uint256 packed)\n    {\n        // pause transfers in bit 0.\n        if (metadata.pauseTransfers) packed |= 1;\n        // pause mint reserves in bit 2.\n        if (metadata.pauseMintPendingReserves) packed |= 1 << 1;\n    }\n\n    /// @notice Expand packed ruleset metadata for the 721 hook.\n    /// @param packedMetadata The packed metadata to expand.\n    /// @return metadata The metadata as a `JB721TiersRulesetMetadata` struct.\n    function expandMetadata(uint16 packedMetadata) internal pure returns (JB721TiersRulesetMetadata memory metadata) {\n        return JB721TiersRulesetMetadata(transfersPaused(packedMetadata), mintPendingReservesPaused(packedMetadata));\n    }\n}\n"
			},
			"src/libraries/JBIpfsDecoder.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/// @title JBIpfsDecoder\n/// @notice Utilities to decode an IPFS hash.\n/// @dev This is fairly gas intensive due to multiple nested loops. Onchain IPFS hash decoding is not advised \n/// storing them as a string *might* be more efficient for that use-case.\nlibrary JBIpfsDecoder {\n    //*********************************************************************//\n    // ------------------- internal constant properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice Just a kind reminder to our readers.\n    /// @dev Used in `base58ToString`\n    bytes internal constant ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n    function decode(string memory baseUri, bytes32 hexString) internal pure returns (string memory) {\n        // All IPFS hashes start with a fixed sequence (0x12 and 0x20)\n        bytes memory completeHexString = abi.encodePacked(bytes2(0x1220), hexString);\n\n        // Convert the hex string to a hash\n        string memory ipfsHash = _toBase58(completeHexString);\n\n        // Concatenate with the base URI\n        return string(abi.encodePacked(baseUri, ipfsHash));\n    }\n\n    /// @notice Convert a hex string to base58\n    /// @notice Written by Martin Ludfall - Licence: MIT\n    function _toBase58(bytes memory source) private pure returns (string memory) {\n        if (source.length == 0) return new string(0);\n\n        uint8[] memory digits = new uint8[](46); // hash size with the prefix\n\n        digits[0] = 0;\n\n        uint8 digitlength = 1;\n        uint256 sourceLength = source.length;\n\n        for (uint256 i; i < sourceLength; i++) {\n            uint256 carry = uint8(source[i]);\n\n            for (uint256 j; j < digitlength;) {\n                carry += uint256(digits[j]) << 8; // mul 256\n                digits[j] = uint8(carry % 58);\n                carry = carry / 58;\n\n                unchecked {\n                    ++j;\n                }\n            }\n\n            while (carry > 0) {\n                digits[digitlength] = uint8(carry % 58);\n                unchecked {\n                    ++digitlength;\n                }\n                carry = carry / 58;\n            }\n        }\n        return string(_toAlphabet(_reverse(_truncate(digits, digitlength))));\n    }\n\n    function _truncate(uint8[] memory array, uint8 length) private pure returns (uint8[] memory) {\n        uint8[] memory output = new uint8[](length);\n        for (uint256 i; i < length; i++) {\n            output[i] = array[i];\n        }\n        return output;\n    }\n\n    function _reverse(uint8[] memory input) private pure returns (uint8[] memory) {\n        uint256 inputLength = input.length;\n        uint8[] memory output = new uint8[](inputLength);\n        for (uint256 i; i < inputLength; i++) {\n            unchecked {\n                output[i] = input[input.length - 1 - i];\n            }\n        }\n        return output;\n    }\n\n    function _toAlphabet(uint8[] memory indices) private pure returns (bytes memory) {\n        uint256 indicesLength = indices.length;\n        bytes memory output = new bytes(indicesLength);\n        for (uint256 i; i < indicesLength; i++) {\n            output[i] = ALPHABET[indices[i]];\n        }\n        return output;\n    }\n}\n"
			},
			"src/structs/JB721InitTiersConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPrices} from \"@bananapus/core/src/interfaces/IJBPrices.sol\";\n\nimport {JB721TierConfig} from \"./JB721TierConfig.sol\";\n\n/// @notice Config to initialize a `JB721TiersHook` with tiers and price data.\n/// @dev The `tiers` must be sorted by price (from least to greatest).\n/// @custom:member tiers The tiers to initialize the hook with.\n/// @custom:member currency The currency that the tier prices are denoted in. See `JBPrices`.\n/// @custom:member decimals The number of decimals in the fixed point tier prices.\n/// @custom:member prices A contract that exposes price feeds that can be used to calculate prices in different\n/// currencies. To only accept payments in `currency`, set `prices` to the zero address. See `JBPrices`.\nstruct JB721InitTiersConfig {\n    JB721TierConfig[] tiers;\n    uint32 currency;\n    uint8 decimals;\n    IJBPrices prices;\n}\n"
			},
			"src/structs/JB721TiersMintReservesConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member tierId The ID of the tier to mint from.\n/// @custom:member count The number of NFTs to mint from that tier.\nstruct JB721TiersMintReservesConfig {\n    uint32 tierId;\n    uint16 count;\n}\n"
			},
			"src/structs/JB721TiersRulesetMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice `JB721TiersHook` options which are packed and stored in the corresponding `JBRulesetMetadata.metadata` on a\n/// per-ruleset basis.\n/// @custom:member pauseTransfers A boolean indicating whether NFT transfers are paused during this ruleset.\n/// @custom:member pauseMintPendingReserves A boolean indicating whether pending/outstanding NFT reserves can be minted\n/// during this ruleset.\nstruct JB721TiersRulesetMetadata {\n    bool pauseTransfers;\n    bool pauseMintPendingReserves;\n}\n"
			},
			"src/structs/JB721TiersSetDiscountPercentConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member tierId The ID of the tier to set the discount percent for.\n/// @custom:member discountPercent The discount percent to set for the tier.\nstruct JB721TiersSetDiscountPercentConfig {\n    uint32 tierId;\n    uint16 discountPercent;\n}\n"
			},
			"node_modules/@bananapus/address-registry/src/interfaces/IJBAddressRegistry.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBAddressRegistry {\n    event AddressRegistered(address indexed addr, address indexed deployer, address caller);\n\n    function deployerOf(address addr) external view returns (address deployer);\n\n    function registerAddress(address deployer, uint256 nonce) external;\n    function registerAddress(address deployer, bytes32 salt, bytes calldata bytecode) external;\n}\n"
			},
			"node_modules/solady/src/utils/LibClone.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Minimal proxy library.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n/// @author Minimal proxy by 0age (https://github.com/0age)\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\n///\n/// @dev Minimal proxy:\n/// Although the sw0nt pattern saves 5 gas over the ERC1167 pattern during runtime,\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\n/// which saves 4 gas over the ERC1167 pattern during runtime, and has the smallest bytecode.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Minimal proxy (PUSH0 variant):\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \"_PUSH0\" as\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\n/// Please use with caution.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Clones with immutable args (CWIA):\n/// The implementation of CWIA here is does NOT append the immutable args into the calldata\n/// passed into delegatecall. It is simply an ERC1167 minimal proxy with the immutable arguments\n/// appended to the back of the runtime bytecode.\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n///\n/// @dev Minimal ERC1967 proxy:\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Minimal ERC1967 proxy with immutable args:\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n/// - Automatically verified on Etherscan.\n///\n/// @dev ERC1967I proxy:\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\n///\n/// @dev ERC1967I proxy with immutable args:\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n///\n/// @dev Minimal ERC1967 beacon proxy:\n/// A minimal beacon proxy, intended to be upgraded with an upgradable beacon.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Minimal ERC1967 beacon proxy with immutable args:\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n/// - Automatically verified on Etherscan.\n///\n/// @dev ERC1967I beacon proxy:\n/// An variant of the minimal ERC1967 beacon proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\n///\n/// @dev ERC1967I proxy with immutable args:\n/// An variant of the minimal ERC1967 beacon proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// - Uses the identity precompile (0x4) to copy args during deployment.\nlibrary LibClone {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The keccak256 of deployed code for the clone proxy,\n    /// with the implementation set to `address(0)`.\n    bytes32 internal constant CLONE_CODE_HASH =\n        0x48db2cfdb2853fce0b464f1f93a1996469459df3ab6c812106074c4106a1eb1f;\n\n    /// @dev The keccak256 of deployed code for the PUSH0 proxy,\n    /// with the implementation set to `address(0)`.\n    bytes32 internal constant PUSH0_CLONE_CODE_HASH =\n        0x67bc6bde1b84d66e267c718ba44cf3928a615d29885537955cb43d44b3e789dc;\n\n    /// @dev The keccak256 of deployed code for the ERC-1167 CWIA proxy,\n    /// with the implementation set to `address(0)`.\n    bytes32 internal constant CWIA_CODE_HASH =\n        0x3cf92464268225a4513da40a34d967354684c32cd0edd67b5f668dfe3550e940;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.\n    bytes32 internal constant ERC1967_CODE_HASH =\n        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.\n    bytes32 internal constant ERC1967I_CODE_HASH =\n        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 beacon proxy.\n    bytes32 internal constant ERC1967_BEACON_PROXY_CODE_HASH =\n        0x14044459af17bc4f0f5aa2f658cb692add77d1302c29fe2aebab005eea9d1162;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 beacon proxy.\n    bytes32 internal constant ERC1967I_BEACON_PROXY_CODE_HASH =\n        0xf8c46d2793d5aa984eb827aeaba4b63aedcab80119212fce827309788735519a;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Unable to deploy the clone.\n    error DeploymentFailed();\n\n    /// @dev The salt must start with either the zero address or `by`.\n    error SaltDoesNotStartWith();\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  MINIMAL PROXY OPERATIONS                  */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Deploys a clone of `implementation`.\n    function clone(address implementation) internal returns (address instance) {\n        instance = clone(0, implementation);\n    }\n\n    /// @dev Deploys a clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(value, 0x0c, 0x35)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(value, 0x0c, 0x35, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the clone of `implementation`.\n    function initCode(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\n            mstore(add(c, 0x28), implementation)\n            mstore(add(c, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            mstore(c, 0x35) // Store the length.\n            mstore(0x40, add(c, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            hash := keccak256(0x0c, 0x35)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the clone of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    function clone_PUSH0(address implementation) internal returns (address instance) {\n        instance = clone_PUSH0(0, implementation);\n    }\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone_PUSH0(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 5f         | PUSH0             | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (45 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 5f      | PUSH0          | 0                      |                       |\n             * 5f      | PUSH0          | 0 0                    |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create(value, 0x0e, 0x36)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create2(value, 0x0e, 0x36, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.\n    function initCode_PUSH0(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\n            mstore(add(c, 0x26), implementation) // 20\n            mstore(add(c, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            mstore(c, 0x36) // Store the length.\n            mstore(0x40, add(c, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            hash := keccak256(0x0e, 0x36)\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the PUSH0 clone of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress_PUSH0(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash_PUSH0(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `args`.\n    function clone(address implementation, bytes memory args) internal returns (address instance) {\n        instance = clone(0, implementation, args);\n    }\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `args`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                        |\n             * ---------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                        |\n             * ---------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                               |\n             * 3d         | RETURNDATASIZE    | 0 r       |                               |\n             * 81         | DUP2              | r 0 r     |                               |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                               |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                               |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code    |\n             * f3         | RETURN            |           | [0..runSize): runtime code    |\n             * ---------------------------------------------------------------------------|\n             * RUNTIME (45 bytes + extraLength)                                           |\n             * ---------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                  | Memory                |\n             * ---------------------------------------------------------------------------|\n             *                                                                            |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                    |                       |\n             * 3d       | RETURNDATASIZE | 0 cds                  |                       |\n             * 3d       | RETURNDATASIZE | 0 0 cds                |                       |\n             * 37       | CALLDATACOPY   |                        | [0..cds): calldata    |\n             *                                                                            |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                      | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 0                    | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 0 0                  | [0..cds): calldata    |\n             * 36       | CALLDATASIZE   | cds 0 0 0              | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr  | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a       | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4       | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                            |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0          | [0..cds): calldata    |\n             * 82       | DUP3           | 0 rds success 0         | [0..cds): calldata   |\n             * 80       | DUP1           | 0 0 rds success 0      | [0..cds): calldata    |\n             * 3e       | RETURNDATACOPY | success 0              | [0..rds): returndata  |\n             * 90       | SWAP1          | 0 success              | [0..rds): returndata  |\n             * 3d       | RETURNDATASIZE | rds 0 success          | [0..rds): returndata  |\n             * 91       | SWAP2          | success 0 rds          | [0..rds): returndata  |\n             *                                                                            |\n             * 60 0x2b  | PUSH1 0x2b     | 0x2b success 0 rds     | [0..rds): returndata  |\n             * 57       | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                            |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                        | [0..rds): returndata  |\n             *                                                                            |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3       | RETURN         |                        | [0..rds): returndata  |\n             * ---------------------------------------------------------------------------+\n             */\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            instance := create(value, add(m, add(0x0b, lt(n, 0xffd3))), add(n, 0x37))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `args` and `salt`.\n    function cloneDeterministic(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, args, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `args` and `salt`.\n    function cloneDeterministic(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            instance := create2(value, add(m, add(0x0b, lt(n, 0xffd3))), add(n, 0x37), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `args` and `salt`.\n    /// This method does not revert if the clone has already been deployed.\n    function createDeterministicClone(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicClone(0, implementation, args, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `args` and `salt`.\n    /// This method does not revert if the clone has already been deployed.\n    function createDeterministicClone(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            // forgefmt: disable-next-item\n            mstore(add(m, gt(n, 0xffd2)), add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x0c), add(n, 0x37)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x0c), add(n, 0x37), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `args`.\n    function initCode(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffd2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x57), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x37), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(c, 0x28), implementation)\n            mstore(add(c, 0x14), add(0x61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            mstore(c, add(0x37, n)) // Store the length.\n            mstore(add(c, add(n, 0x57)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0x77))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `args`.\n    function initCodeHash(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffd2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x43), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0x61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            hash := keccak256(add(m, 0x0c), add(n, 0x37))\n        }\n    }\n\n    /// @dev Returns the address of the clone of\n    /// `implementation` using immutable arguments encoded in `args`, with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnClone(instance, 0, 2 ** 256 - 1)`.\n    function argsOnClone(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x2d))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x2d, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnClone(instance, start, 2 ** 256 - 1)`.\n    function argsOnClone(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x2d))\n            extcodecopy(instance, add(args, 0x20), add(start, 0x2d), add(n, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the clone with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnClone(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x0d), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x2d)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    function deployERC1967(address implementation) internal returns (address instance) {\n        instance = deployERC1967(0, implementation);\n    }\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (61 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create(value, 0x21, 0x5f)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create2(value, 0x21, 0x5f, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x21, 0x5f, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\n    function initCodeERC1967(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x60), 0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300)\n            mstore(add(c, 0x40), 0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc)\n            mstore(add(c, 0x20), or(shl(24, implementation), 0x600951))\n            mstore(add(c, 0x09), 0x603d3d8160223d3973)\n            mstore(c, 0x5f) // Store the length.\n            mstore(0x40, add(c, 0x80)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            hash := keccak256(0x21, 0x5f)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 proxy of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*    MINIMAL ERC1967 PROXY WITH IMMUTABLE ARGS OPERATIONS    */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation` and `args`.\n    function deployERC1967(address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967(0, implementation, args);\n    }\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation` and `args`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            instance := create(value, m, add(n, 0x60))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    function deployDeterministicERC1967(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, args, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            instance := create2(value, m, add(n, 0x60), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, args, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(m, add(n, 0x60)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, m, add(n, 0x60), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation` and `args`.\n    function initCodeERC1967(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffc2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x80), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x60), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(c, 0x40), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(add(c, 0x20), 0x6009)\n            mstore(add(c, 0x1e), implementation)\n            mstore(add(c, 0x0a), add(0x61003d3d8160233d3973, shl(56, n)))\n            mstore(c, add(n, 0x60)) // Store the length.\n            mstore(add(c, add(n, 0x80)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0xa0))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation` and `args`.\n    function initCodeHashERC1967(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffc2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x60), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            mstore(0x00, add(0x61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            hash := keccak256(m, add(n, 0x60))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 proxy of `implementation`, `args`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x3d))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x3d, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x3d))\n            extcodecopy(instance, add(args, 0x20), add(start, 0x3d), add(n, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967 with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x1d), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x3d)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                 ERC1967I PROXY OPERATIONS                  */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\n    // This code path skips the delegatecall and directly returns the `implementation` address.\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\n    // proxy's code is equal to `ERC1967I_CODE_HASH`.\n\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\n    function deployERC1967I(address implementation) internal returns (address instance) {\n        instance = deployERC1967I(0, implementation);\n    }\n\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967I(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 58         | PC             | 1 cds            |                                 |\n             * 14         | EQ             | eqs              |                                 |\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\n             * 57         | JUMPI          |                  |                                 |\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  |                                 |\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\n             * 52         | MSTORE         |                  | [0..32): implementation address |\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\n             * f3         | RETURN         |                  | [0..32): implementation address |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I proxy of `implementation`.\n    function initCodeERC1967I(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x74), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(c, 0x54), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(c, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(c, 0x1d), implementation)\n            mstore(add(c, 0x09), 0x60523d8160223d3973)\n            mstore(add(c, 0x94), 0)\n            mstore(c, 0x74) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I proxy of `implementation`.\n    function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I proxy of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*       ERC1967I PROXY WITH IMMUTABLE ARGS OPERATIONS        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation` and `args`.\n    function deployERC1967I(address implementation, bytes memory args) internal returns (address) {\n        return deployERC1967I(0, implementation, args);\n    }\n\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation` and `args`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967I(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n\n            mstore(add(m, 0x6b), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x4b), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x2b), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe6100523d8160233d3973, shl(56, n)))\n\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            instance := create(value, add(m, add(0x15, lt(n, 0xffae))), add(0x75, n))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation`, `args`, and `salt`.\n    function deployDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, args, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation`,`args`,  and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967I(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n\n            mstore(add(m, 0x6b), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x4b), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x2b), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe6100523d8160233d3973, shl(56, n)))\n\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            instance := create2(value, add(m, add(0x15, lt(n, 0xffae))), add(0x75, n), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation`, `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, args, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation`,`args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x75), n))\n            mstore(add(m, 0x55), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x35), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x15), 0x5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x16, 0x600f)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(gt(n, 0xffad), add(0xfe6100523d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(m, add(n, 0x75)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, m, add(0x75, n), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I proxy of `implementation`and `args`.\n    function initCodeERC1967I(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x95), i), mload(add(add(args, 0x20), i)))\n            }\n\n            mstore(add(c, 0x75), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(c, 0x55), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(c, 0x35), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(c, 0x1e), implementation)\n            mstore(add(c, 0x0a), add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(add(c, add(n, 0x95)), 0)\n            mstore(c, add(0x75, n)) // Store the length.\n            mstore(0x40, add(c, add(n, 0xb5))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I proxy of `implementation` and `args.\n    function initCodeHashERC1967I(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x75), i), mload(add(add(args, 0x20), i)))\n            }\n\n            mstore(add(m, 0x55), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x35), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x15), 0x5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x16, 0x600f)\n            mstore(0x14, implementation)\n            mstore(0x00, add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            hash := keccak256(m, add(0x75, n))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I proxy of `implementation`, 'args` with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967I(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967I(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x52))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x52, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967I(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967I(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x52))\n            extcodecopy(instance, add(args, 0x20), add(start, 0x52), add(n, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967 with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967I(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x32), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x52)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                ERC1967 BOOTSTRAP OPERATIONS                */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // A bootstrap is a minimal UUPS implementation that allows an ERC1967 proxy\n    // pointing to it to be upgraded. The ERC1967 proxy can then be deployed to a\n    // deterministic address independent of the implementation:\n    // ```\n    //     address bootstrap = LibClone.erc1967Bootstrap();\n    //     address instance = LibClone.deployDeterministicERC1967(0, bootstrap, salt);\n    //     LibClone.bootstrapERC1967(bootstrap, implementation);\n    // ```\n\n    /// @dev Deploys the ERC1967 bootstrap if it has not been deployed.\n    function erc1967Bootstrap() internal returns (address) {\n        return erc1967Bootstrap(address(this));\n    }\n\n    /// @dev Deploys the ERC1967 bootstrap if it has not been deployed.\n    function erc1967Bootstrap(address authorizedUpgrader) internal returns (address bootstrap) {\n        bytes memory c = initCodeERC1967Bootstrap(authorizedUpgrader);\n        bootstrap = predictDeterministicAddress(keccak256(c), bytes32(0), address(this));\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(extcodesize(bootstrap)) {\n                if iszero(create2(0, add(c, 0x20), mload(c), 0)) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Replaces the implementation at `instance`.\n    function bootstrapERC1967(address instance, address implementation) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, implementation)\n            if iszero(call(gas(), instance, 0, 0x0c, 0x14, codesize(), 0x00)) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Replaces the implementation at `instance`, and then call it with `data`.\n    function bootstrapERC1967AndCall(address instance, address implementation, bytes memory data)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            mstore(data, implementation)\n            if iszero(call(gas(), instance, 0, add(data, 0x0c), add(n, 0x14), codesize(), 0x00)) {\n                if iszero(returndatasize()) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                returndatacopy(mload(0x40), 0x00, returndatasize())\n                revert(mload(0x40), returndatasize())\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /// @dev Returns the implementation address of the ERC1967 bootstrap for this contract.\n    function predictDeterministicAddressERC1967Bootstrap() internal view returns (address) {\n        return predictDeterministicAddressERC1967Bootstrap(address(this), address(this));\n    }\n\n    /// @dev Returns the implementation address of the ERC1967 bootstrap for this contract.\n    function predictDeterministicAddressERC1967Bootstrap(\n        address authorizedUpgrader,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 hash = initCodeHashERC1967Bootstrap(authorizedUpgrader);\n        return predictDeterministicAddress(hash, bytes32(0), deployer);\n    }\n\n    /// @dev Returns the initialization code of the ERC1967 bootstrap.\n    function initCodeERC1967Bootstrap(address authorizedUpgrader)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x80), 0x3d3560601c5af46047573d6000383e3d38fd0000000000000000000000000000)\n            mstore(add(c, 0x60), 0xa920a3ca505d382bbc55601436116049575b005b363d3d373d3d601436036014)\n            mstore(add(c, 0x40), 0x0338573d3560601c7f360894a13ba1a3210667c828492db98dca3e2076cc3735)\n            mstore(add(c, 0x20), authorizedUpgrader)\n            mstore(add(c, 0x0c), 0x606880600a3d393df3fe3373)\n            mstore(c, 0x72)\n            mstore(0x40, add(c, 0xa0))\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967 bootstrap.\n    function initCodeHashERC1967Bootstrap(address authorizedUpgrader)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(initCodeERC1967Bootstrap(authorizedUpgrader));\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*          MINIMAL ERC1967 BEACON PROXY OPERATIONS           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // Note: If you use this proxy, you MUST make sure that the beacon is a\n    // valid ERC1967 beacon. This means that the beacon must always return a valid\n    // address upon a staticcall to `implementation()`, given sufficient gas.\n    // For performance, the deployment operations and the proxy assumes that the\n    // beacon is always valid and will NOT validate it.\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\n    function deployERC1967BeaconProxy(address beacon) internal returns (address instance) {\n        instance = deployERC1967BeaconProxy(0, beacon);\n    }\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967BeaconProxy(uint256 value, address beacon)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\n             * fa            | STATICCALL       | succ                        | impl            |\n             * 50            | POP              |                             | impl            |\n             * 36            | CALLDATASIZE     | cds                         | impl            |\n             * 51            | MLOAD            | impl                        | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x4d    | PUSH1 0x4d     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\n    function deployDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 beacon proxy.\n    function initCodeERC1967BeaconProxy(address beacon) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x74), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(c, 0x54), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(c, 0x34), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(c, 0x1d), beacon)\n            mstore(add(c, 0x09), 0x60523d8160223d3973)\n            mstore(add(c, 0x94), 0)\n            mstore(c, 0x74) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 beacon proxy.\n    function initCodeHashERC1967BeaconProxy(address beacon) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 beacon proxy, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967BeaconProxy(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*    ERC1967 BEACON PROXY WITH IMMUTABLE ARGS OPERATIONS     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy with `args`.\n    function deployERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967BeaconProxy(0, beacon, args);\n    }\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy with `args`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967BeaconProxy(uint256 value, address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            instance := create(value, add(m, 0x16), add(n, 0x75))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    function deployDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967BeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            instance := create2(value, add(m, 0x16), add(n, 0x75), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967BeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x16), add(n, 0x75)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x16), add(n, 0x75), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 beacon proxy.\n    function initCodeERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x95), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x75), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(c, 0x55), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(c, 0x35), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(c, 0x1e), beacon)\n            mstore(add(c, 0x0a), add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(c, add(n, 0x75)) // Store the length.\n            mstore(add(c, add(n, 0x95)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0xb5))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 beacon proxy with `args`.\n    function initCodeHashERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x8b), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            mstore(m, add(0x6100523d8160233d3973, shl(56, n)))\n            hash := keccak256(add(m, 0x16), add(n, 0x75))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 beacon proxy with `args`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967BeaconProxy(\n        address beacon,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967BeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967BeaconProxy(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x52))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x52, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967BeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967BeaconProxy(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x52))\n            extcodecopy(instance, add(args, 0x20), add(start, 0x52), add(n, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967 beacon proxy with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967BeaconProxy(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x32), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x52)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*              ERC1967I BEACON PROXY OPERATIONS              */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\n    // This code path skips the delegatecall and directly returns the `implementation` address.\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\n    // proxy's code is equal to `ERC1967_BEACON_PROXY_CODE_HASH`.\n    //\n    // If you use this proxy, you MUST make sure that the beacon is a\n    // valid ERC1967 beacon. This means that the beacon must always return a valid\n    // address upon a staticcall to `implementation()`, given sufficient gas.\n    // For performance, the deployment operations and the proxy assumes that the\n    // beacon is always valid and will NOT validate it.\n\n    /// @dev Deploys a ERC1967I beacon proxy.\n    function deployERC1967IBeaconProxy(address beacon) internal returns (address instance) {\n        instance = deployERC1967IBeaconProxy(0, beacon);\n    }\n\n    /// @dev Deploys a ERC1967I beacon proxy.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967IBeaconProxy(uint256 value, address beacon)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (87 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\n             * fa            | STATICCALL       | succ                        | impl            |\n             * ~~~~~~ check calldatasize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 36            | CALLDATASIZE     | cds succ                    |                 |\n             * 14            | EQ               |                             | impl            |\n             * 60 0x52       | PUSH1 0x52       |                             | impl            |\n             * 57            | JUMPI            |                             | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 36            | CALLDATASIZE     | cds                         | impl            |\n             * 51            | MLOAD            | impl                        | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 60 0x01    | PUSH1 0x01     | 1 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52    | PUSH1 0x52     | dest succ        | [1..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [1..returndatasize): returndata |\n             * 60 0x01    | PUSH1 0x01     | 1 rds            | [1..returndatasize): returndata |\n             * fd         | REVERT         |                  | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [1..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [1..returndatasize): returndata |\n             * 60 0x01    | PUSH1 0x01     | 1 rds            | [1..returndatasize): returndata |\n             * f3         | RETURN         |                  | [1..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create(value, 0x07, 0x79)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `salt`.\n    function deployDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967IBeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create2(value, 0x07, 0x79, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967IBeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x07, 0x79))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x07, 0x79, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I beacon proxy.\n    function initCodeERC1967IBeaconProxy(address beacon) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x79), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x59), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x39), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x1d), beacon)\n            mstore(add(c, 0x09), 0x60573d8160223d3973)\n            mstore(add(c, 0x99), 0)\n            mstore(c, 0x79) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I beacon proxy.\n    function initCodeHashERC1967IBeaconProxy(address beacon) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            hash := keccak256(0x07, 0x79)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I beacon proxy, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967IBeaconProxy(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967IBeaconProxy(beacon);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*    ERC1967I BEACON PROXY WITH IMMUTABLE ARGS OPERATIONS    */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Deploys a ERC1967I beacon proxy with `args.\n    function deployERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967IBeaconProxy(0, beacon, args);\n    }\n\n    /// @dev Deploys a ERC1967I beacon proxy with `args.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967IBeaconProxy(uint256 value, address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            instance := create(value, add(m, 0x16), add(n, 0x7a))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    function deployDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967IBeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967IBeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            instance := create2(value, add(m, 0x16), add(n, 0x7a), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967IBeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x16), add(n, 0x7a)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x16), add(n, 0x7a), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I beacon proxy with `args`.\n    function initCodeERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffa8))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x9a), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x7a), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x5a), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x3a), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x1e), beacon)\n            mstore(add(c, 0x0a), add(0x6100573d8160233d3973, shl(56, n)))\n            mstore(add(c, add(n, 0x9a)), 0)\n            mstore(c, add(n, 0x7a)) // Store the length.\n            mstore(0x40, add(c, add(n, 0xba))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I beacon proxy with `args`.\n    function initCodeHashERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let c := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffa8))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x90), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x14), beacon)\n            mstore(c, add(0x6100573d8160233d3973, shl(56, n)))\n            hash := keccak256(add(c, 0x16), add(n, 0x7a))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I beacon proxy, with  `args` and salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967IBeaconProxy(\n        address beacon,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967IBeaconProxy(beacon, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967IBeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967IBeaconProxy(address instance)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x57))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x57, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967IBeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967IBeaconProxy(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x57))\n            extcodecopy(instance, add(args, 0x20), add(start, 0x57), add(n, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967I beacon proxy with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967IBeaconProxy(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x37), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x57)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      OTHER OPERATIONS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `address(0)` if the implementation address cannot be determined.\n    function implementationOf(address instance) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { extcodecopy(instance, 0x00, 0x00, 0x57) } 1 {} {\n                if mload(0x2d) {\n                    // ERC1967I and ERC1967IBeaconProxy detection.\n                    if or(\n                        eq(keccak256(0x00, 0x52), ERC1967I_CODE_HASH),\n                        eq(keccak256(0x00, 0x57), ERC1967I_BEACON_PROXY_CODE_HASH)\n                    ) {\n                        pop(staticcall(gas(), instance, 0x00, 0x01, 0x00, 0x20))\n                        result := mload(0x0c)\n                        break\n                    }\n                }\n                // 0age clone detection.\n                result := mload(0x0b)\n                codecopy(0x0b, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                if iszero(xor(keccak256(0x00, 0x2c), CLONE_CODE_HASH)) { break }\n                mstore(0x0b, result) // Restore the zeroized memory.\n                // CWIA detection.\n                result := mload(0x0a)\n                codecopy(0x0a, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                if iszero(xor(keccak256(0x00, 0x2d), CWIA_CODE_HASH)) { break }\n                mstore(0x0a, result) // Restore the zeroized memory.\n                // PUSH0 clone detection.\n                result := mload(0x09)\n                codecopy(0x09, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                result := shr(xor(keccak256(0x00, 0x2d), PUSH0_CLONE_CODE_HASH), result)\n                break\n            }\n            result := shr(96, result)\n            mstore(0x37, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address when a contract with initialization code hash,\n    /// `hash`, is deployed with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\n    function checkStartsWith(bytes32 salt, address by) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or `by`.\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the `bytes32` at `offset` in `args`, without any bounds checks.\n    /// To load an address, you can use `address(bytes20(argLoad(args, offset)))`.\n    function argLoad(bytes memory args, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(args, 0x20), offset))\n        }\n    }\n}\n"
			},
			"src/JB721TiersHookDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IJBAddressRegistry} from \"@bananapus/address-registry/src/interfaces/IJBAddressRegistry.sol\";\nimport {JBOwnable} from \"@bananapus/ownable/src/JBOwnable.sol\";\nimport {LibClone} from \"solady/src/utils/LibClone.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\n\nimport {JB721TiersHook} from \"./JB721TiersHook.sol\";\nimport {IJB721TiersHookDeployer} from \"./interfaces/IJB721TiersHookDeployer.sol\";\nimport {IJB721TiersHook} from \"./interfaces/IJB721TiersHook.sol\";\nimport {IJB721TiersHookStore} from \"./interfaces/IJB721TiersHookStore.sol\";\nimport {JBDeploy721TiersHookConfig} from \"./structs/JBDeploy721TiersHookConfig.sol\";\n\n/// @title JB721TiersHookDeployer\n/// @notice Deploys a `JB721TiersHook` for an existing project.\ncontract JB721TiersHookDeployer is ERC2771Context, IJB721TiersHookDeployer {\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice A registry which stores references to contracts and their deployers.\n    IJBAddressRegistry public immutable ADDRESS_REGISTRY;\n\n    /// @notice A 721 tiers hook.\n    JB721TiersHook public immutable HOOK;\n\n    /// @notice The contract that stores and manages data for this contract's NFTs.\n    IJB721TiersHookStore public immutable STORE;\n\n    //*********************************************************************//\n    // ----------------------- internal properties ----------------------- //\n    //*********************************************************************//\n\n    /// @notice This contract's current nonce, used for the Juicebox address registry.\n    uint256 internal _nonce;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param hook Reference copy of a hook.\n    /// @param addressRegistry A registry which stores references to contracts and their deployers.\n    constructor(\n        JB721TiersHook hook,\n        IJB721TiersHookStore store,\n        IJBAddressRegistry addressRegistry,\n        address trustedForwarder\n    )\n        ERC2771Context(trustedForwarder)\n    {\n        HOOK = hook;\n        STORE = store;\n        ADDRESS_REGISTRY = addressRegistry;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Deploys a 721 tiers hook for the specified project.\n    /// @param projectId The ID of the project to deploy the hook for.\n    /// @param deployTiersHookConfig The config to deploy the hook with, which determines its behavior.\n    /// @param salt A salt to use for the deterministic deployment.\n    /// @return newHook The address of the newly deployed hook.\n    function deployHookFor(\n        uint256 projectId,\n        JBDeploy721TiersHookConfig calldata deployTiersHookConfig,\n        bytes32 salt\n    )\n        external\n        override\n        returns (IJB721TiersHook newHook)\n    {\n        // Deploy the governance variant specified by the config.\n        newHook = IJB721TiersHook(\n            salt == bytes32(0)\n                ? LibClone.clone(address(HOOK))\n                : LibClone.cloneDeterministic({\n                    value: 0,\n                    implementation: address(HOOK),\n                    salt: keccak256(abi.encode(msg.sender, salt))\n                })\n        );\n\n        emit HookDeployed({projectId: projectId, hook: newHook, caller: msg.sender});\n\n        newHook.initialize({\n            projectId: projectId,\n            name: deployTiersHookConfig.name,\n            symbol: deployTiersHookConfig.symbol,\n            baseUri: deployTiersHookConfig.baseUri,\n            tokenUriResolver: deployTiersHookConfig.tokenUriResolver,\n            contractUri: deployTiersHookConfig.contractUri,\n            tiersConfig: deployTiersHookConfig.tiersConfig,\n            flags: deployTiersHookConfig.flags\n        });\n\n        // Transfer the hook's ownership to the address that called this function.\n        JBOwnable(address(newHook)).transferOwnership(_msgSender());\n\n        // Increment the nonce.\n        ++_nonce;\n\n        // Add the hook to the address registry. This contract's nonce starts at 1.\n        salt == bytes32(0)\n            ? ADDRESS_REGISTRY.registerAddress({deployer: address(this), nonce: _nonce})\n            : ADDRESS_REGISTRY.registerAddress({\n                deployer: address(this),\n                salt: keccak256(abi.encode(msg.sender, salt)),\n                bytecode: LibClone.initCode(address(HOOK))\n            });\n    }\n}\n"
			},
			"src/interfaces/IJB721TiersHookDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJB721TiersHook} from \"./IJB721TiersHook.sol\";\nimport {JBDeploy721TiersHookConfig} from \"../structs/JBDeploy721TiersHookConfig.sol\";\n\ninterface IJB721TiersHookDeployer {\n    event HookDeployed(uint256 indexed projectId, IJB721TiersHook hook, address caller);\n\n    function deployHookFor(\n        uint256 projectId,\n        JBDeploy721TiersHookConfig memory deployTiersHookConfig,\n        bytes32 salt\n    )\n        external\n        returns (IJB721TiersHook hook);\n}\n"
			},
			"src/structs/JBDeploy721TiersHookConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JB721InitTiersConfig} from \"./JB721InitTiersConfig.sol\";\nimport {JB721TiersHookFlags} from \"./JB721TiersHookFlags.sol\";\nimport {IJB721TokenUriResolver} from \"../interfaces/IJB721TokenUriResolver.sol\";\n\n/// @custom:member name The NFT collection's name.\n/// @custom:member symbol The NFT collection's symbol.\n/// @custom:member baseUri The URI to use as a base for full NFT URIs.\n/// @custom:member tokenUriResolver The contract responsible for resolving the URI for each NFT.\n/// @custom:member contractUri The URI where this contract's metadata can be found.\n/// @custom:member tiersConfig The NFT tiers and pricing config to launch the hook with.\n/// @custom:member reserveBeneficiary The default reserved beneficiary for all tiers.\n/// @custom:member flags A set of boolean options to configure the hook with.\nstruct JBDeploy721TiersHookConfig {\n    string name;\n    string symbol;\n    string baseUri;\n    IJB721TokenUriResolver tokenUriResolver;\n    string contractUri;\n    JB721InitTiersConfig tiersConfig;\n    address reserveBeneficiary;\n    JB721TiersHookFlags flags;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBController.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./IJBFundAccessLimits.sol\";\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./../structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./../structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {JBTerminalConfig} from \"./../structs/JBTerminalConfig.sol\";\n\ninterface IJBController is IERC165, IJBProjectUriRegistry, IJBDirectoryAccessControl {\n    event BurnTokens(\n        address indexed holder, uint256 indexed projectId, uint256 tokenCount, string memo, address caller\n    );\n    event LaunchProject(uint256 rulesetId, uint256 projectId, string projectUri, string memo, address caller);\n    event LaunchRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event MintTokens(\n        address indexed beneficiary,\n        uint256 indexed projectId,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        uint256 reservedPercent,\n        address caller\n    );\n    event PrepMigration(uint256 indexed projectId, address from, address caller);\n    event QueueRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event ReservedDistributionReverted(\n        uint256 indexed projectId, JBSplit split, uint256 tokenCount, bytes reason, address caller\n    );\n    event SendReservedTokensToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed groupId,\n        JBSplit split,\n        uint256 tokenCount,\n        address caller\n    );\n    event SendReservedTokensToSplits(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address owner,\n        uint256 tokenCount,\n        uint256 leftoverAmount,\n        address caller\n    );\n    event SetUri(uint256 indexed projectId, string uri, address caller);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n    function FUND_ACCESS_LIMITS() external view returns (IJBFundAccessLimits);\n    function PRICES() external view returns (IJBPrices);\n    function PROJECTS() external view returns (IJBProjects);\n    function RULESETS() external view returns (IJBRulesets);\n    function SPLITS() external view returns (IJBSplits);\n    function TOKENS() external view returns (IJBTokens);\n\n    function allRulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRulesetWithMetadata[] memory rulesets);\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory, JBRulesetMetadata memory metadata, JBApprovalStatus);\n    function pendingReservedTokenBalanceOf(uint256 projectId) external view returns (uint256);\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view returns (uint256);\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function addPriceFeed(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n    function burnTokensOf(address holder, uint256 projectId, uint256 tokenCount, string calldata memo) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 tokenCount, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 projectId);\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedPercent\n    )\n        external\n        returns (uint256 beneficiaryTokenCount);\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function sendReservedTokensToSplitsOf(uint256 projectId) external returns (uint256);\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] calldata splitGroups) external;\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 creditCount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBDirectoryAccessControl.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBDirectoryAccessControl {\n    function setControllerAllowed(uint256 projectId) external view returns (bool);\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBFundAccessLimits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./../structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"./../structs/JBFundAccessLimitGroup.sol\";\n\ninterface IJBFundAccessLimits {\n    event SetFundAccessLimits(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        JBFundAccessLimitGroup fundAccessLimitGroup,\n        address caller\n    );\n\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 payoutLimit);\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory payoutLimits);\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 surplusAllowance);\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory surplusAllowances);\n\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] memory fundAccessLimitGroups\n    )\n        external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjectUriRegistry.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBProjectUriRegistry {\n    function uriOf(uint256 projectId) external view returns (string memory);\n    function setUriOf(uint256 projectId, string calldata uri) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplitHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBSplitHookContext} from \"../structs/JBSplitHookContext.sol\";\n\n/// @title Split hook\n/// @notice Allows processing a single split with custom logic.\n/// @dev The split hook's address should be set as the `hook` in the relevant split.\ninterface IJBSplitHook is IERC165 {\n    /// @notice If a split has a split hook, payment terminals and controllers call this function while processing the\n    /// split.\n    /// @dev Critical business logic should be protected by appropriate access control. The tokens and/or native tokens\n    /// are optimistically transferred to the split hook when this function is called.\n    /// @param context The context passed by the terminal/controller to the split hook as a `JBSplitHookContext` struct:\n    function processSplitWith(JBSplitHookContext calldata context) external payable;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBSplits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\n\ninterface IJBSplits {\n    event SetSplit(\n        uint256 indexed projectId, uint256 indexed rulesetId, uint256 indexed groupId, JBSplit split, address caller\n    );\n\n    function FALLBACK_RULESET_ID() external view returns (uint256);\n\n    function splitsOf(uint256 projectId, uint256 rulesetId, uint256 groupId) external view returns (JBSplit[] memory);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] memory splitGroups) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBToken.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBToken {\n    function balanceOf(address account) external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n\n    function initialize(string memory name, string memory symbol, address owner) external;\n    function burn(address account, uint256 amount) external;\n    function mint(address account, uint256 amount) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokens.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBToken} from \"./IJBToken.sol\";\n\ninterface IJBTokens {\n    event DeployERC20(\n        uint256 indexed projectId, IJBToken indexed token, string name, string symbol, bytes32 salt, address caller\n    );\n    event Burn(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 count,\n        uint256 creditBalance,\n        uint256 tokenBalance,\n        address caller\n    );\n    event ClaimTokens(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 creditBalance,\n        uint256 count,\n        address beneficiary,\n        address caller\n    );\n    event Mint(\n        address indexed holder, uint256 indexed projectId, uint256 count, bool shouldClaimTokens, address caller\n    );\n    event SetToken(uint256 indexed projectId, IJBToken indexed token, address caller);\n    event TransferCredits(\n        address indexed holder, uint256 indexed projectId, address indexed recipient, uint256 count, address caller\n    );\n\n    function creditBalanceOf(address holder, uint256 projectId) external view returns (uint256);\n    function projectIdOf(IJBToken token) external view returns (uint256);\n    function tokenOf(uint256 projectId) external view returns (IJBToken);\n    function totalCreditSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalBalanceOf(address holder, uint256 projectId) external view returns (uint256 result);\n    function totalSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function burnFrom(address holder, uint256 projectId, uint256 count) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 count, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function mintFor(address holder, uint256 projectId, uint256 count) external;\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 count) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBCurrencyAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The amount of the currency.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBCurrencyAmount {\n    uint224 amount;\n    uint32 currency;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBFundAccessLimitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./JBCurrencyAmount.sol\";\n\n/// @dev Payout limit example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH, then\n/// the project can pay out 5 USD worth of ETH during a ruleset.\n/// @dev Surplus allowance example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH,\n/// then the project can pay out 5 USD worth of ETH from its surplus during a ruleset. A project's surplus is its\n/// balance minus its current combined payout limit.\n/// @dev If a project has multiple payout limits or surplus allowances, they are all available. They can all be used\n/// during a single ruleset.\n/// @dev The payout limits' and surplus allowances' fixed point amounts have the same number of decimals as the\n/// terminal.\n/// @custom:member terminal The terminal that the payout limits and surplus allowances apply to.\n/// @custom:member token The token that the payout limits and surplus allowances apply to within the `terminal`.\n/// @custom:member payoutLimits An array of payout limits. The payout limits cumulatively dictate the maximum value of\n/// `token`s a project can pay out from its balance in a terminal during a ruleset. Each payout limit can have a unique\n/// currency and amount.\n/// @custom:member surplusAllowances An array of surplus allowances. The surplus allowances cumulatively dictates the\n/// maximum value of `token`s a project can pay out from its surplus (balance less payouts) in a terminal during a\n/// ruleset. Each surplus allowance can have a unique currency and amount.\nstruct JBFundAccessLimitGroup {\n    address terminal;\n    address token;\n    JBCurrencyAmount[] payoutLimits;\n    JBCurrencyAmount[] surplusAllowances;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"../interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"./JBFundAccessLimitGroup.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\nimport {JBSplitGroup} from \"./JBSplitGroup.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active  any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a cut `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member weightCutPercent A percent by how much the `weight` of the subsequent ruleset should be reduced, if\n/// the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_WEIGHT_CUT_PERCENT`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `_payoutLimit` and `_surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBRulesetConfig {\n    uint48 mustStartAtOrAfter;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    JBRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBRulesetWithMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBRuleset} from \"./JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\n\n/// @custom:member ruleset The ruleset.\n/// @custom:member metadata The ruleset's metadata.\nstruct JBRulesetWithMetadata {\n    JBRuleset ruleset;\n    JBRulesetMetadata metadata;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplit.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplitHook} from \"./../interfaces/IJBSplitHook.sol\";\n\n/// @notice Splits are used to send a percentage of a total token amount to a specific contract, project, or address.\n/// Splits are used to send payouts and reserved tokens.\n/// @dev 1. If a non-zero split hook contract is specified, this split's tokens are sent there along with this split's\n/// properties.\n/// @dev 2. Otherwise, if a non-zero project ID is specified, this split's tokens are used to `pay` it through its\n/// terminal if possible, or sent to the project's owner if not. If this payment yields tokens, those go to the split's\n/// `beneficiary`.\n/// @dev 3. Otherwise, this split's tokens are sent directly to the `beneficiary`.\n/// @dev To summarize, this split's tokens are sent according to the following priority: `split hook` > `projectId` >\n/// `beneficiary`.\n/// @custom:member preferAddToBalance If this split were to `pay` a project through its terminal, this flag indicates\n/// whether it should prefer using the terminal's `addToBalance` function instead.\n/// @custom:member percent The percent of the total token amount that this split sends. This number is out of\n/// `JBConstants.SPLITS_TOTAL_PERCENT`.\n/// @custom:member projectId The ID of a project to `pay`, if applicable. Resulting tokens will be routed to the\n/// `beneficiary`.\n/// @custom:member beneficiary Receives this split's tokens if the `hook` and `projectId` are zero. If the `projectId`\n/// is specified, the `beneficiary` receives any project tokens minted by this split.\n/// @custom:member lockedUntil The split cannot be changed until this timestamp. The `lockedUntil` timestamp can be\n/// increased while a split is locked. If `lockedUntil` is zero, this split can be changed at any time.\n/// @custom:member hook A contract which will receive this split's tokens and properties, and can define custom\n/// behavior.\nstruct JBSplit {\n    bool preferAddToBalance;\n    uint32 percent;\n    uint56 projectId;\n    address payable beneficiary;\n    uint48 lockedUntil;\n    IJBSplitHook hook;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member groupId An identifier for the group. By convention, this ID is `uint256(uint160(tokenAddress))` for\n/// payouts and `1` for reserved tokens.\n/// @custom:member splits The splits in the group.\nstruct JBSplitGroup {\n    uint256 groupId;\n    JBSplit[] splits;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBSplitHookContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member token The token being sent to the split hook.\n/// @custom:member amount The amount being sent to the split hook, as a fixed point number.\n/// @custom:member decimals The number of decimals in the amount.\n/// @custom:member projectId The project the split belongs to.\n/// @custom:member groupId The group the split belongs to. By convention, this ID is `uint256(uint160(tokenAddress))`\n/// for payouts and `1` for reserved tokens.\n/// @custom:member split The split which specified the hook.\nstruct JBSplitHookContext {\n    address token;\n    uint256 amount;\n    uint256 decimals;\n    uint256 projectId;\n    uint256 groupId;\n    JBSplit split;\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBTerminalConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAccountingContext} from \"./JBAccountingContext.sol\";\nimport {IJBTerminal} from \"./../interfaces/IJBTerminal.sol\";\n\n/// @custom:member terminal The terminal to configure.\n/// @custom:member accountingContextsToAccept The accounting contexts to accept from the terminal.\nstruct JBTerminalConfig {\n    IJBTerminal terminal;\n    JBAccountingContext[] accountingContextsToAccept;\n}\n"
			},
			"src/JB721TiersHookProjectDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissioned} from \"@bananapus/core/src/abstract/JBPermissioned.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {JBRulesetConfig} from \"@bananapus/core/src/structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"@bananapus/core/src/structs/JBRulesetMetadata.sol\";\nimport {JBOwnable} from \"@bananapus/ownable/src/JBOwnable.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\n\nimport {IJB721TiersHookDeployer} from \"./interfaces/IJB721TiersHookDeployer.sol\";\nimport {IJB721TiersHookProjectDeployer} from \"./interfaces/IJB721TiersHookProjectDeployer.sol\";\nimport {IJB721TiersHook} from \"./interfaces/IJB721TiersHook.sol\";\nimport {JBDeploy721TiersHookConfig} from \"./structs/JBDeploy721TiersHookConfig.sol\";\nimport {JBLaunchRulesetsConfig} from \"./structs/JBLaunchRulesetsConfig.sol\";\nimport {JBQueueRulesetsConfig} from \"./structs/JBQueueRulesetsConfig.sol\";\nimport {JBLaunchProjectConfig} from \"./structs/JBLaunchProjectConfig.sol\";\nimport {JBPayDataHookRulesetConfig} from \"./structs/JBPayDataHookRulesetConfig.sol\";\n\n/// @title JB721TiersHookProjectDeployer\n/// @notice Deploys a project and a 721 tiers hook for it. Can be used to queue rulesets for the project if given\n/// `JBPermissionIds.QUEUE_RULESETS`.\ncontract JB721TiersHookProjectDeployer is JBPermissioned, IJB721TiersHookProjectDeployer {\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice The 721 tiers hook deployer.\n    IJB721TiersHookDeployer public immutable override HOOK_DEPLOYER;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory The directory of terminals and controllers for projects.\n    /// @param permissions A contract storing permissions.\n    /// @param hookDeployer The 721 tiers hook deployer.\n    constructor(\n        IJBDirectory directory,\n        IJBPermissions permissions,\n        IJB721TiersHookDeployer hookDeployer\n    )\n        JBPermissioned(permissions)\n    {\n        DIRECTORY = directory;\n        HOOK_DEPLOYER = hookDeployer;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Launches a new project with a 721 tiers hook attached.\n    /// @param owner The address to set as the owner of the project. The ERC-721 which confers this project's ownership\n    /// will be sent to this address.\n    /// @param deployTiersHookConfig Configuration which dictates the behavior of the 721 tiers hook which is being\n    /// deployed.\n    /// @param launchProjectConfig Configuration which dictates the behavior of the project which is being launched.\n    /// @param controller The controller that the project's rulesets will be queued with.\n    /// @param salt A salt to use for the deterministic deployment.\n    /// @return projectId The ID of the newly launched project.\n    /// @return hook The 721 tiers hook that was deployed for the project.\n    function launchProjectFor(\n        address owner,\n        JBDeploy721TiersHookConfig calldata deployTiersHookConfig,\n        JBLaunchProjectConfig calldata launchProjectConfig,\n        IJBController controller,\n        bytes32 salt\n    )\n        external\n        override\n        returns (uint256 projectId, IJB721TiersHook hook)\n    {\n        // Get the project's ID, optimistically knowing it will be one greater than the current number of projects.\n        projectId = DIRECTORY.PROJECTS().count() + 1;\n\n        // Deploy the hook.\n        hook = HOOK_DEPLOYER.deployHookFor({\n            projectId: projectId,\n            deployTiersHookConfig: deployTiersHookConfig,\n            salt: salt == bytes32(0) ? bytes32(0) : keccak256(abi.encode(msg.sender, salt))\n        });\n\n        // Launch the project.\n        _launchProjectFor({\n            owner: owner,\n            launchProjectConfig: launchProjectConfig,\n            dataHook: hook,\n            controller: controller\n        });\n\n        // Transfer the hook's ownership to the project.\n        JBOwnable(address(hook)).transferOwnershipToProject(projectId);\n    }\n\n    /// @notice Launches rulesets for a project with an attached 721 tiers hook.\n    /// @dev Only a project's owner or an operator with the `QUEUE_RULESETS & SET_TERMINALS` permission can launch its\n    /// rulesets.\n    /// @param projectId The ID of the project that rulesets are being launched for.\n    /// @param deployTiersHookConfig Configuration which dictates the behavior of the 721 tiers hook which is being\n    /// deployed.\n    /// @param launchRulesetsConfig Configuration which dictates the project's new rulesets.\n    /// @param controller The controller that the project's rulesets will be queued with.\n    /// @param salt A salt to use for the deterministic deployment.\n    /// @return rulesetId The ID of the successfully created ruleset.\n    /// @return hook The 721 tiers hook that was deployed for the project.\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBDeploy721TiersHookConfig calldata deployTiersHookConfig,\n        JBLaunchRulesetsConfig calldata launchRulesetsConfig,\n        IJBController controller,\n        bytes32 salt\n    )\n        external\n        override\n        returns (uint256 rulesetId, IJB721TiersHook hook)\n    {\n        // Get the project's projects contract.\n        IJBProjects PROJECTS = DIRECTORY.PROJECTS();\n\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.QUEUE_RULESETS\n        });\n\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_TERMINALS\n        });\n\n        // Deploy the hook.\n        hook = HOOK_DEPLOYER.deployHookFor({\n            projectId: projectId,\n            deployTiersHookConfig: deployTiersHookConfig,\n            salt: salt == bytes32(0) ? bytes32(0) : keccak256(abi.encode(msg.sender, salt))\n        });\n\n        // Transfer the hook's ownership to the project.\n        JBOwnable(address(hook)).transferOwnershipToProject(projectId);\n\n        // Launch the rulesets.\n        rulesetId = _launchRulesetsFor({\n            projectId: projectId,\n            launchRulesetsConfig: launchRulesetsConfig,\n            dataHook: hook,\n            controller: controller\n        });\n    }\n\n    /// @notice Queues rulesets for a project with an attached 721 tiers hook.\n    /// @dev Only a project's owner or an operator with the `QUEUE_RULESETS` permission can queue its rulesets.\n    /// @param projectId The ID of the project that rulesets are being queued for.\n    /// @param deployTiersHookConfig Configuration which dictates the behavior of the 721 tiers hook which is being\n    /// deployed.\n    /// @param queueRulesetsConfig Configuration which dictates the project's newly queued rulesets.\n    /// @param controller The controller that the project's rulesets will be queued with.\n    /// @param salt A salt to use for the deterministic deployment.\n    /// @return rulesetId The ID of the successfully created ruleset.\n    /// @return hook The 721 tiers hook that was deployed for the project.\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBDeploy721TiersHookConfig calldata deployTiersHookConfig,\n        JBQueueRulesetsConfig calldata queueRulesetsConfig,\n        IJBController controller,\n        bytes32 salt\n    )\n        external\n        override\n        returns (uint256 rulesetId, IJB721TiersHook hook)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: DIRECTORY.PROJECTS().ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.QUEUE_RULESETS\n        });\n\n        // Deploy the hook.\n        hook = HOOK_DEPLOYER.deployHookFor({\n            projectId: projectId,\n            deployTiersHookConfig: deployTiersHookConfig,\n            salt: salt == bytes32(0) ? bytes32(0) : keccak256(abi.encode(msg.sender, salt))\n        });\n\n        // Transfer the hook's ownership to the project.\n        JBOwnable(address(hook)).transferOwnershipToProject(projectId);\n\n        // Queue the rulesets.\n        rulesetId = _queueRulesetsOf({\n            projectId: projectId,\n            queueRulesetsConfig: queueRulesetsConfig,\n            dataHook: hook,\n            controller: controller\n        });\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Launches a project.\n    /// @param owner The address that will own the project.\n    /// @param launchProjectConfig Configuration which dictates the behavior of the project which is being launched.\n    /// @param dataHook The data hook to use for the project.\n    /// @param controller The controller that the project's rulesets will be queued with.\n    function _launchProjectFor(\n        address owner,\n        JBLaunchProjectConfig memory launchProjectConfig,\n        IJB721TiersHook dataHook,\n        IJBController controller\n    )\n        internal\n    {\n        // Initialize an array of ruleset configurations.\n        JBRulesetConfig[] memory rulesetConfigurations =\n            new JBRulesetConfig[](launchProjectConfig.rulesetConfigurations.length);\n\n        // Set the data hook to be active for pay transactions for each ruleset configuration.\n        for (uint256 i; i < launchProjectConfig.rulesetConfigurations.length; i++) {\n            // Set the pay data ruleset config being iterated on.\n            JBPayDataHookRulesetConfig memory payDataRulesetConfig = launchProjectConfig.rulesetConfigurations[i];\n\n            // Add the ruleset config.\n            rulesetConfigurations[i] = JBRulesetConfig({\n                mustStartAtOrAfter: payDataRulesetConfig.mustStartAtOrAfter,\n                duration: payDataRulesetConfig.duration,\n                weight: payDataRulesetConfig.weight,\n                weightCutPercent: payDataRulesetConfig.weightCutPercent,\n                approvalHook: payDataRulesetConfig.approvalHook,\n                metadata: JBRulesetMetadata({\n                    reservedPercent: payDataRulesetConfig.metadata.reservedPercent,\n                    cashOutTaxRate: payDataRulesetConfig.metadata.cashOutTaxRate,\n                    baseCurrency: payDataRulesetConfig.metadata.baseCurrency,\n                    pausePay: payDataRulesetConfig.metadata.pausePay,\n                    pauseCreditTransfers: payDataRulesetConfig.metadata.pauseCreditTransfers,\n                    allowOwnerMinting: payDataRulesetConfig.metadata.allowOwnerMinting,\n                    allowSetCustomToken: false,\n                    allowTerminalMigration: payDataRulesetConfig.metadata.allowTerminalMigration,\n                    allowSetTerminals: payDataRulesetConfig.metadata.allowSetTerminals,\n                    allowSetController: payDataRulesetConfig.metadata.allowSetController,\n                    allowAddAccountingContext: payDataRulesetConfig.metadata.allowAddAccountingContext,\n                    allowAddPriceFeed: payDataRulesetConfig.metadata.allowAddPriceFeed,\n                    ownerMustSendPayouts: payDataRulesetConfig.metadata.ownerMustSendPayouts,\n                    holdFees: payDataRulesetConfig.metadata.holdFees,\n                    useTotalSurplusForCashOuts: payDataRulesetConfig.metadata.useTotalSurplusForCashOuts,\n                    useDataHookForPay: true,\n                    useDataHookForCashOut: payDataRulesetConfig.metadata.useDataHookForCashOut,\n                    dataHook: address(dataHook),\n                    metadata: payDataRulesetConfig.metadata.metadata\n                }),\n                splitGroups: payDataRulesetConfig.splitGroups,\n                fundAccessLimitGroups: payDataRulesetConfig.fundAccessLimitGroups\n            });\n        }\n\n        // Launch the project.\n        // slither-disable-next-line unused-return\n        controller.launchProjectFor({\n            owner: owner,\n            projectUri: launchProjectConfig.projectUri,\n            rulesetConfigurations: rulesetConfigurations,\n            terminalConfigurations: launchProjectConfig.terminalConfigurations,\n            memo: launchProjectConfig.memo\n        });\n    }\n\n    /// @notice Launches rulesets for a project.\n    /// @param projectId The ID of the project to launch rulesets for.\n    /// @param launchRulesetsConfig Configuration which dictates the behavior of the project's rulesets.\n    /// @param dataHook The data hook to use for the project.\n    /// @param controller The controller that the project's rulesets will be queued with.\n    /// @return rulesetId The ID of the successfully created ruleset.\n    function _launchRulesetsFor(\n        uint256 projectId,\n        JBLaunchRulesetsConfig memory launchRulesetsConfig,\n        IJB721TiersHook dataHook,\n        IJBController controller\n    )\n        internal\n        returns (uint256)\n    {\n        // Initialize an array of ruleset configurations.\n        JBRulesetConfig[] memory rulesetConfigurations =\n            new JBRulesetConfig[](launchRulesetsConfig.rulesetConfigurations.length);\n\n        // Set the data hook to be active for pay transactions for each ruleset configuration.\n        for (uint256 i; i < launchRulesetsConfig.rulesetConfigurations.length; i++) {\n            // Set the pay data ruleset config being iterated on.\n            JBPayDataHookRulesetConfig memory payDataRulesetConfig = launchRulesetsConfig.rulesetConfigurations[i];\n\n            // Add the ruleset config.\n            rulesetConfigurations[i] = JBRulesetConfig({\n                mustStartAtOrAfter: payDataRulesetConfig.mustStartAtOrAfter,\n                duration: payDataRulesetConfig.duration,\n                weight: payDataRulesetConfig.weight,\n                weightCutPercent: payDataRulesetConfig.weightCutPercent,\n                approvalHook: payDataRulesetConfig.approvalHook,\n                metadata: JBRulesetMetadata({\n                    reservedPercent: payDataRulesetConfig.metadata.reservedPercent,\n                    cashOutTaxRate: payDataRulesetConfig.metadata.cashOutTaxRate,\n                    baseCurrency: payDataRulesetConfig.metadata.baseCurrency,\n                    pausePay: payDataRulesetConfig.metadata.pausePay,\n                    pauseCreditTransfers: payDataRulesetConfig.metadata.pauseCreditTransfers,\n                    allowOwnerMinting: payDataRulesetConfig.metadata.allowOwnerMinting,\n                    allowSetCustomToken: false,\n                    allowTerminalMigration: payDataRulesetConfig.metadata.allowTerminalMigration,\n                    allowSetTerminals: payDataRulesetConfig.metadata.allowSetTerminals,\n                    allowSetController: payDataRulesetConfig.metadata.allowSetController,\n                    allowAddAccountingContext: payDataRulesetConfig.metadata.allowAddAccountingContext,\n                    allowAddPriceFeed: payDataRulesetConfig.metadata.allowAddPriceFeed,\n                    ownerMustSendPayouts: payDataRulesetConfig.metadata.ownerMustSendPayouts,\n                    holdFees: payDataRulesetConfig.metadata.holdFees,\n                    useTotalSurplusForCashOuts: payDataRulesetConfig.metadata.useTotalSurplusForCashOuts,\n                    useDataHookForPay: true,\n                    useDataHookForCashOut: payDataRulesetConfig.metadata.useDataHookForCashOut,\n                    dataHook: address(dataHook),\n                    metadata: payDataRulesetConfig.metadata.metadata\n                }),\n                splitGroups: payDataRulesetConfig.splitGroups,\n                fundAccessLimitGroups: payDataRulesetConfig.fundAccessLimitGroups\n            });\n        }\n\n        // Launch the rulesets.\n        return controller.launchRulesetsFor({\n            projectId: projectId,\n            rulesetConfigurations: rulesetConfigurations,\n            terminalConfigurations: launchRulesetsConfig.terminalConfigurations,\n            memo: launchRulesetsConfig.memo\n        });\n    }\n\n    /// @notice Queues rulesets for a project.\n    /// @param projectId The ID of the project to queue rulesets for.\n    /// @param queueRulesetsConfig Configuration which dictates the behavior of the project's rulesets.\n    /// @param dataHook The data hook to use for the project.\n    /// @param controller The controller that the project's rulesets will be queued with.\n    /// @return The ID of the successfully created ruleset.\n    function _queueRulesetsOf(\n        uint256 projectId,\n        JBQueueRulesetsConfig memory queueRulesetsConfig,\n        IJB721TiersHook dataHook,\n        IJBController controller\n    )\n        internal\n        returns (uint256)\n    {\n        // Initialize an array of ruleset configurations.\n        JBRulesetConfig[] memory rulesetConfigurations =\n            new JBRulesetConfig[](queueRulesetsConfig.rulesetConfigurations.length);\n\n        // Set the data hook to be active for pay transactions for each ruleset configuration.\n        for (uint256 i; i < queueRulesetsConfig.rulesetConfigurations.length; i++) {\n            // Set the pay data ruleset config being iterated on.\n            JBPayDataHookRulesetConfig memory payDataRulesetConfig = queueRulesetsConfig.rulesetConfigurations[i];\n\n            // Add the ruleset config.\n            rulesetConfigurations[i] = JBRulesetConfig({\n                mustStartAtOrAfter: payDataRulesetConfig.mustStartAtOrAfter,\n                duration: payDataRulesetConfig.duration,\n                weight: payDataRulesetConfig.weight,\n                weightCutPercent: payDataRulesetConfig.weightCutPercent,\n                approvalHook: payDataRulesetConfig.approvalHook,\n                metadata: JBRulesetMetadata({\n                    reservedPercent: payDataRulesetConfig.metadata.reservedPercent,\n                    cashOutTaxRate: payDataRulesetConfig.metadata.cashOutTaxRate,\n                    baseCurrency: payDataRulesetConfig.metadata.baseCurrency,\n                    pausePay: payDataRulesetConfig.metadata.pausePay,\n                    pauseCreditTransfers: payDataRulesetConfig.metadata.pauseCreditTransfers,\n                    allowOwnerMinting: payDataRulesetConfig.metadata.allowOwnerMinting,\n                    allowSetCustomToken: false,\n                    allowTerminalMigration: payDataRulesetConfig.metadata.allowTerminalMigration,\n                    allowSetTerminals: payDataRulesetConfig.metadata.allowSetTerminals,\n                    allowSetController: payDataRulesetConfig.metadata.allowSetController,\n                    allowAddAccountingContext: payDataRulesetConfig.metadata.allowAddAccountingContext,\n                    allowAddPriceFeed: payDataRulesetConfig.metadata.allowAddPriceFeed,\n                    ownerMustSendPayouts: payDataRulesetConfig.metadata.ownerMustSendPayouts,\n                    holdFees: payDataRulesetConfig.metadata.holdFees,\n                    useTotalSurplusForCashOuts: payDataRulesetConfig.metadata.useTotalSurplusForCashOuts,\n                    useDataHookForPay: true,\n                    useDataHookForCashOut: payDataRulesetConfig.metadata.useDataHookForCashOut,\n                    dataHook: address(dataHook),\n                    metadata: payDataRulesetConfig.metadata.metadata\n                }),\n                splitGroups: payDataRulesetConfig.splitGroups,\n                fundAccessLimitGroups: payDataRulesetConfig.fundAccessLimitGroups\n            });\n        }\n\n        // Queue the rulesets.\n        return controller.queueRulesetsOf({\n            projectId: projectId,\n            rulesetConfigurations: rulesetConfigurations,\n            memo: queueRulesetsConfig.memo\n        });\n    }\n}\n"
			},
			"src/interfaces/IJB721TiersHookProjectDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"@bananapus/core/src/interfaces/IJBDirectory.sol\";\nimport {IJBController} from \"@bananapus/core/src/interfaces/IJBController.sol\";\n\nimport {IJB721TiersHook} from \"./IJB721TiersHook.sol\";\nimport {IJB721TiersHookDeployer} from \"./IJB721TiersHookDeployer.sol\";\nimport {JBDeploy721TiersHookConfig} from \"../structs/JBDeploy721TiersHookConfig.sol\";\nimport {JBLaunchProjectConfig} from \"../structs/JBLaunchProjectConfig.sol\";\nimport {JBLaunchRulesetsConfig} from \"../structs/JBLaunchRulesetsConfig.sol\";\nimport {JBQueueRulesetsConfig} from \"../structs/JBQueueRulesetsConfig.sol\";\n\ninterface IJB721TiersHookProjectDeployer {\n    function DIRECTORY() external view returns (IJBDirectory);\n    function HOOK_DEPLOYER() external view returns (IJB721TiersHookDeployer);\n\n    function launchProjectFor(\n        address owner,\n        JBDeploy721TiersHookConfig memory deployTiersHookConfig,\n        JBLaunchProjectConfig memory launchProjectConfig,\n        IJBController controller,\n        bytes32 salt\n    )\n        external\n        returns (uint256 projectId, IJB721TiersHook hook);\n\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBDeploy721TiersHookConfig memory deployTiersHookConfig,\n        JBLaunchRulesetsConfig memory launchRulesetsConfig,\n        IJBController controller,\n        bytes32 salt\n    )\n        external\n        returns (uint256 rulesetId, IJB721TiersHook hook);\n\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBDeploy721TiersHookConfig memory deployTiersHookConfig,\n        JBQueueRulesetsConfig memory queueRulesetsConfig,\n        IJBController controller,\n        bytes32 salt\n    )\n        external\n        returns (uint256 rulesetId, IJB721TiersHook hook);\n}\n"
			},
			"src/structs/JBLaunchProjectConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\n\nimport {JBPayDataHookRulesetConfig} from \"./JBPayDataHookRulesetConfig.sol\";\n\n/// @custom:member projectUri Metadata URI to associate with the project. This can be updated any time by the owner of\n/// the project.\n/// @custom:member rulesetConfigurations The ruleset configurations to queue.\n/// @custom:member terminalConfigurations The terminal configurations to add for the project.\n/// @custom:member memo A memo to pass along to the emitted event.\nstruct JBLaunchProjectConfig {\n    string projectUri;\n    JBPayDataHookRulesetConfig[] rulesetConfigurations;\n    JBTerminalConfig[] terminalConfigurations;\n    string memo;\n}\n"
			},
			"src/structs/JBLaunchRulesetsConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTerminalConfig} from \"@bananapus/core/src/structs/JBTerminalConfig.sol\";\n\nimport {JBPayDataHookRulesetConfig} from \"./JBPayDataHookRulesetConfig.sol\";\n\n/// @custom:member projectId The ID of the project to launch rulesets for.\n/// @custom:member rulesetConfigurations The ruleset configurations to queue.\n/// @custom:member terminalConfigurations The terminal configurations to add for the project.\n/// @custom:member memo A memo to pass along to the emitted event.\nstruct JBLaunchRulesetsConfig {\n    uint56 projectId;\n    JBPayDataHookRulesetConfig[] rulesetConfigurations;\n    JBTerminalConfig[] terminalConfigurations;\n    string memo;\n}\n"
			},
			"src/structs/JBPayDataHookRulesetConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"@bananapus/core/src/structs/JBFundAccessLimitGroup.sol\";\nimport {JBSplitGroup} from \"@bananapus/core/src/structs/JBSplitGroup.sol\";\n\nimport {JBPayDataHookRulesetMetadata} from \"./JBPayDataHookRulesetMetadata.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active  any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a decayed `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member weightCutPercent A percent by how much the `weight` of the subsequent ruleset should be reduced, if\n/// the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_WEIGHT_CUT_PERCENT`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `payoutLimit` and `surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBPayDataHookRulesetConfig {\n    uint48 mustStartAtOrAfter;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    JBPayDataHookRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"
			},
			"src/structs/JBPayDataHookRulesetMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedPercent The reserved percent of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_PERCENT`.\n/// @custom:member cashOutTaxRate The cash out tax rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_CASH_OUT_TAX_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member allowAddAccountingContext A flag indicating if a project can add new accounting contexts for its\n/// terminals to use.\n/// @custom:member allowAddPriceFeed A flag indicating if a project can add new price feeds to calculate exchange rates\n/// between its tokens.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForCashOut A flag indicating if cash outs should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the cash out is being fulfilled.\n/// @custom:member useDataHookForCashOuts A flag indicating if the data hook should be used for cash out transactions\n/// during\n/// this ruleset.\n/// @custom:member metadata Metadata of the metadata, up to uint8 in size.\nstruct JBPayDataHookRulesetMetadata {\n    uint16 reservedPercent;\n    uint16 cashOutTaxRate;\n    uint32 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowSetController;\n    bool allowAddAccountingContext;\n    bool allowAddPriceFeed;\n    bool ownerMustSendPayouts;\n    bool holdFees;\n    bool useTotalSurplusForCashOuts;\n    bool useDataHookForCashOut;\n    uint16 metadata;\n}\n"
			},
			"src/structs/JBQueueRulesetsConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPayDataHookRulesetConfig} from \"./JBPayDataHookRulesetConfig.sol\";\n\n/// @custom:member projectId The ID of the project to launch rulesets for.\n/// @custom:member rulesetConfigurations The ruleset configurations to queue.\n/// @custom:member terminalConfigurations The terminal configurations to add for the project.\n/// @custom:member memo A memo to pass along to the emitted event.\nstruct JBQueueRulesetsConfig {\n    uint56 projectId;\n    JBPayDataHookRulesetConfig[] rulesetConfigurations;\n    string memo;\n}\n"
			}
		}
	}
}